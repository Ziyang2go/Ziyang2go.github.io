<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.4"/>
<title>VRay SDK for C++: VRay::VRayRenderer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">VRay SDK for C++
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_v_ray_1_1_v_ray_renderer.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerator</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_v_ray_1_1_v_ray_renderer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">VRay::VRayRenderer Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class wraps the underlying V-Ray render engine and its scene contents.  
 <a href="class_v_ray_1_1_v_ray_renderer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="vraysdk_8hpp_source.html">vraysdk.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer_1_1_v_f_b.html">VFB</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class groups all <a class="el" href="class_v_ray_1_1_v_ray_renderer_1_1_v_f_b.html" title="This class groups all VFB related methods. ">VFB</a> related methods.  <a href="class_v_ray_1_1_v_ray_renderer_1_1_v_f_b.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae765a571a28b610eaf2b6428c6a170ec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae765a571a28b610eaf2b6428c6a170ec"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#ae765a571a28b610eaf2b6428c6a170ec">VRayRenderer</a> ()</td></tr>
<tr class="memdesc:ae765a571a28b610eaf2b6428c6a170ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor which uses default rendering options. <br/></td></tr>
<tr class="separator:ae765a571a28b610eaf2b6428c6a170ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafe291d99437e2916d5e8d088b99525a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aafe291d99437e2916d5e8d088b99525a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#aafe291d99437e2916d5e8d088b99525a">VRayRenderer</a> (const <a class="el" href="struct_v_ray_1_1_renderer_options.html">RendererOptions</a> &amp;rendererOptions)</td></tr>
<tr class="memdesc:aafe291d99437e2916d5e8d088b99525a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor which uses supplied rendering options. <br/></td></tr>
<tr class="separator:aafe291d99437e2916d5e8d088b99525a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6447b1511ea72d8f171c98c4fb2f3f30"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6447b1511ea72d8f171c98c4fb2f3f30"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a6447b1511ea72d8f171c98c4fb2f3f30">~VRayRenderer</a> ()</td></tr>
<tr class="memdesc:a6447b1511ea72d8f171c98c4fb2f3f30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br/></td></tr>
<tr class="separator:a6447b1511ea72d8f171c98c4fb2f3f30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a478cb6103557b3d78baf93684ee490ff"><td class="memItemLeft" align="right" valign="top">AddHostsResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a478cb6103557b3d78baf93684ee490ff">addHosts</a> (const char *hosts) const </td></tr>
<tr class="separator:a478cb6103557b3d78baf93684ee490ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2119e624f5028a49957be113ad0f434b"><td class="memItemLeft" align="right" valign="top">AddHostsResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a2119e624f5028a49957be113ad0f434b">addHosts</a> (const std::string &amp;hosts) const </td></tr>
<tr class="separator:a2119e624f5028a49957be113ad0f434b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5b156d68bda49e3d5cf90b884b998e6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#aa5b156d68bda49e3d5cf90b884b998e6">append</a> (const char *fileName) const </td></tr>
<tr class="separator:aa5b156d68bda49e3d5cf90b884b998e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af619f1728a86571713c27778746848cf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#af619f1728a86571713c27778746848cf">append</a> (const std::string &amp;fileName) const </td></tr>
<tr class="separator:af619f1728a86571713c27778746848cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa648ca10f3883c261f3982015c293961"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#aa648ca10f3883c261f3982015c293961">appendAsText</a> (const char *text) const </td></tr>
<tr class="separator:aa648ca10f3883c261f3982015c293961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c3a8f75aa7d7c12699c77d9a53f47d6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a7c3a8f75aa7d7c12699c77d9a53f47d6">appendAsText</a> (const std::string &amp;text) const </td></tr>
<tr class="separator:a7c3a8f75aa7d7c12699c77d9a53f47d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaad57e3260a9a24698476f4e9ec18cf5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#aaad57e3260a9a24698476f4e9ec18cf5">appendAsTextFiltered</a> (const char *fileName, bool(*callback)(<a class="el" href="class_v_ray_1_1_v_ray_renderer.html">VRayRenderer</a> &amp;, const char *pluginType, std::string &amp;pluginName, void *), const void *userData=NULL)</td></tr>
<tr class="separator:aaad57e3260a9a24698476f4e9ec18cf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1841a26d188f423305bdebfd80fad1f0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a1841a26d188f423305bdebfd80fad1f0">appendAsTextFiltered</a> (const std::string &amp;fileName, bool(*callback)(<a class="el" href="class_v_ray_1_1_v_ray_renderer.html">VRayRenderer</a> &amp;, const char *pluginType, std::string &amp;pluginName, void *), const void *userData=NULL)</td></tr>
<tr class="separator:a1841a26d188f423305bdebfd80fad1f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38573cbc7f19bfa2fd877465d44f704e"><td class="memTemplParams" colspan="2">template&lt;class T , bool(T::*)(VRayRenderer &amp;, const char *pluginType, std::string &amp;pluginName, void *) TMethod&gt; </td></tr>
<tr class="memitem:a38573cbc7f19bfa2fd877465d44f704e"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a38573cbc7f19bfa2fd877465d44f704e">appendAsTextFiltered</a> (const char *fileName, T &amp;obj, const void *userData=NULL)</td></tr>
<tr class="separator:a38573cbc7f19bfa2fd877465d44f704e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd4a8403d82dddcc2f26aaacd9ae1543"><td class="memTemplParams" colspan="2">template&lt;class T , bool(T::*)(VRayRenderer &amp;, const char *pluginType, std::string &amp;pluginName, void *) TMethod&gt; </td></tr>
<tr class="memitem:abd4a8403d82dddcc2f26aaacd9ae1543"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#abd4a8403d82dddcc2f26aaacd9ae1543">appendAsTextFiltered</a> (const std::string &amp;fileName, T &amp;obj, const void *userData=NULL)</td></tr>
<tr class="separator:abd4a8403d82dddcc2f26aaacd9ae1543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27e256b80e53e81ef55c3871428593c8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a27e256b80e53e81ef55c3871428593c8">appendFiltered</a> (const char *fileName, bool(*callback)(<a class="el" href="class_v_ray_1_1_v_ray_renderer.html">VRayRenderer</a> &amp;, const char *pluginType, std::string &amp;pluginName, void *), const void *userData=NULL)</td></tr>
<tr class="separator:a27e256b80e53e81ef55c3871428593c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab25e33041f6c2e44111a2df34ed57b36"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#ab25e33041f6c2e44111a2df34ed57b36">appendFiltered</a> (const std::string &amp;fileName, bool(*callback)(<a class="el" href="class_v_ray_1_1_v_ray_renderer.html">VRayRenderer</a> &amp;, const char *pluginType, std::string &amp;pluginName, void *), const void *userData=NULL)</td></tr>
<tr class="separator:ab25e33041f6c2e44111a2df34ed57b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae29a1d1916e52cf3030771bdb80c5922"><td class="memTemplParams" colspan="2">template&lt;class T , bool(T::*)(VRayRenderer &amp;, const char *pluginType, std::string &amp;pluginName, void *) TMethod&gt; </td></tr>
<tr class="memitem:ae29a1d1916e52cf3030771bdb80c5922"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#ae29a1d1916e52cf3030771bdb80c5922">appendFiltered</a> (const char *fileName, T &amp;obj, const void *userData=NULL)</td></tr>
<tr class="separator:ae29a1d1916e52cf3030771bdb80c5922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ca50e4f468375d5c4efa914a7dc808d"><td class="memTemplParams" colspan="2">template&lt;class T , bool(T::*)(VRayRenderer &amp;, const char *pluginType, std::string &amp;pluginName, void *) TMethod&gt; </td></tr>
<tr class="memitem:a7ca50e4f468375d5c4efa914a7dc808d"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a7ca50e4f468375d5c4efa914a7dc808d">appendFiltered</a> (const std::string &amp;fileName, T &amp;obj, const void *userData=NULL)</td></tr>
<tr class="separator:a7ca50e4f468375d5c4efa914a7dc808d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a738657cec4adecfff74cb0eb2cac2fe6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a738657cec4adecfff74cb0eb2cac2fe6">bucketRenderNearest</a> (int x, int y) const </td></tr>
<tr class="separator:a738657cec4adecfff74cb0eb2cac2fe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a292c087765c748653dcaef7f06fdbfcd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a292c087765c748653dcaef7f06fdbfcd"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a292c087765c748653dcaef7f06fdbfcd">clearAllPropertyValuesUpToTime</a> (double time)</td></tr>
<tr class="memdesc:a292c087765c748653dcaef7f06fdbfcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all keyframe values at times less than 'time'. <br/></td></tr>
<tr class="separator:a292c087765c748653dcaef7f06fdbfcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89b30cc3d6647da7c2712304705b4f64"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a89b30cc3d6647da7c2712304705b4f64">commit</a> (bool force=false)</td></tr>
<tr class="separator:a89b30cc3d6647da7c2712304705b4f64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a4bd372c514d02c94e2f1443ca00fbc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4a4bd372c514d02c94e2f1443ca00fbc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a4a4bd372c514d02c94e2f1443ca00fbc">continueSequence</a> () const </td></tr>
<tr class="memdesc:a4a4bd372c514d02c94e2f1443ca00fbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">When rendering a sequence this starts the next frame after the previous one has completed. It does not continue automatically. <br/></td></tr>
<tr class="separator:a4a4bd372c514d02c94e2f1443ca00fbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3191f9c211050ab354ead75a3906cbc6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a3191f9c211050ab354ead75a3906cbc6">createCombinedProxyFileMesh</a> (const std::vector&lt; <a class="el" href="class_v_ray_1_1_plugin.html">Plugin</a> &gt; &amp;geomStaticMeshPlugins, const std::vector&lt; <a class="el" href="struct_v_ray_1_1_transform.html">Transform</a> &gt; *transforms, const <a class="el" href="struct_v_ray_1_1_proxy_create_params.html">ProxyCreateParams</a> &amp;params)</td></tr>
<tr class="separator:a3191f9c211050ab354ead75a3906cbc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41c6a341512c69cdceca038af7176b88"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a41c6a341512c69cdceca038af7176b88">createProxyFileMesh</a> (const <a class="el" href="class_v_ray_1_1_plugin.html">Plugin</a> &amp;geomStaticMeshPlugin, const <a class="el" href="struct_v_ray_1_1_transform.html">Transform</a> *transform, const <a class="el" href="struct_v_ray_1_1_proxy_create_params.html">ProxyCreateParams</a> &amp;params)</td></tr>
<tr class="separator:a41c6a341512c69cdceca038af7176b88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecce95f4936fbef91554a33e5db1fc54"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#aecce95f4936fbef91554a33e5db1fc54">denoiseNow</a> ()</td></tr>
<tr class="separator:aecce95f4936fbef91554a33e5db1fc54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb19ad37026282797658b036936263d8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#abb19ad37026282797658b036936263d8">exportScene</a> (const char *filePath) const </td></tr>
<tr class="separator:abb19ad37026282797658b036936263d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bbe72781303d3375aef24c4e08db66e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a6bbe72781303d3375aef24c4e08db66e">exportScene</a> (const std::string &amp;filePath) const </td></tr>
<tr class="separator:a6bbe72781303d3375aef24c4e08db66e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacd965e58058c5020d20e86a046f3487"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#aacd965e58058c5020d20e86a046f3487">exportScene</a> (const char *filePath, const <a class="el" href="struct_v_ray_1_1_v_ray_export_settings.html">VRayExportSettings</a> &amp;settings) const </td></tr>
<tr class="separator:aacd965e58058c5020d20e86a046f3487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73077d94c3874b82c03529756684921c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a73077d94c3874b82c03529756684921c">exportScene</a> (const std::string &amp;filePath, const <a class="el" href="struct_v_ray_1_1_v_ray_export_settings.html">VRayExportSettings</a> &amp;settings) const </td></tr>
<tr class="separator:a73077d94c3874b82c03529756684921c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3d4d41990b01a0da532591c9bc141c0"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#ad3d4d41990b01a0da532591c9bc141c0">getActiveHosts</a> () const </td></tr>
<tr class="separator:ad3d4d41990b01a0da532591c9bc141c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2b60dc969bac1d7376bc3bd2c408d8d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#ad2b60dc969bac1d7376bc3bd2c408d8d">getAllHosts</a> () const </td></tr>
<tr class="separator:ad2b60dc969bac1d7376bc3bd2c408d8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6114d23a9de6309191671b7cb761b684"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6114d23a9de6309191671b7cb761b684"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a6114d23a9de6309191671b7cb761b684">getAutoCommit</a> () const </td></tr>
<tr class="memdesc:a6114d23a9de6309191671b7cb761b684"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current state of the autoCommit flag. <br/></td></tr>
<tr class="separator:a6114d23a9de6309191671b7cb761b684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3bb50cd9f177d4d89ea7e2fb8a5a113"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af3bb50cd9f177d4d89ea7e2fb8a5a113"></a>
std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#af3bb50cd9f177d4d89ea7e2fb8a5a113">getAvailablePlugins</a> () const </td></tr>
<tr class="memdesc:af3bb50cd9f177d4d89ea7e2fb8a5a113"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the class names of all available V-Ray plugin classes loaded from dynamic libraries. <br/></td></tr>
<tr class="separator:af3bb50cd9f177d4d89ea7e2fb8a5a113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09ba74e9355dabe7b493a2037166e910"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a09ba74e9355dabe7b493a2037166e910"></a>
<a class="el" href="struct_v_ray_1_1_box.html">Box</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a09ba74e9355dabe7b493a2037166e910">getBoundingBox</a> () const </td></tr>
<tr class="memdesc:a09ba74e9355dabe7b493a2037166e910"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current bounding box of the scene. <br/></td></tr>
<tr class="separator:a09ba74e9355dabe7b493a2037166e910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a460fe3d48e7a60fac80b5e36a1fbf2b3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a460fe3d48e7a60fac80b5e36a1fbf2b3"></a>
<a class="el" href="struct_v_ray_1_1_box.html">Box</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a460fe3d48e7a60fac80b5e36a1fbf2b3">getBoundingBox</a> (bool &amp;ok) const </td></tr>
<tr class="memdesc:a460fe3d48e7a60fac80b5e36a1fbf2b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current bounding box of the scene. <br/></td></tr>
<tr class="separator:a460fe3d48e7a60fac80b5e36a1fbf2b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15b98f857149203645a93fcb918d1699"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a15b98f857149203645a93fcb918d1699"></a>
<a class="el" href="class_v_ray_1_1_plugin.html">Plugin</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a15b98f857149203645a93fcb918d1699">getCamera</a> () const </td></tr>
<tr class="memdesc:a15b98f857149203645a93fcb918d1699"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current camera plugin. Don't use this unless you need to use <a class="el" href="class_v_ray_1_1_v_ray_renderer.html#aee73eb4931a7639f96c973f44e956243">setCamera()</a> - see the comments on setCamera. <br/></td></tr>
<tr class="separator:a15b98f857149203645a93fcb918d1699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85695b30bb0c598223933ec7f70a9bfc"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a85695b30bb0c598223933ec7f70a9bfc">getCausticsSize</a> ()</td></tr>
<tr class="separator:a85695b30bb0c598223933ec7f70a9bfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a220b7cc51f5bbb4a2134ef6af808cfac"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="struct_v_ray_1_1_compute_device_info.html">ComputeDeviceInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a220b7cc51f5bbb4a2134ef6af808cfac">getComputeDevicesCUDA</a> ()</td></tr>
<tr class="separator:a220b7cc51f5bbb4a2134ef6af808cfac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af361640faf5882a193649b2902a1c51e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="struct_v_ray_1_1_compute_device_info.html">ComputeDeviceInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#af361640faf5882a193649b2902a1c51e">getComputeDevicesCurrentEngine</a> ()</td></tr>
<tr class="separator:af361640faf5882a193649b2902a1c51e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbbdeee7ba35a6c6e594639a30dcf587"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="struct_v_ray_1_1_compute_device_info.html">ComputeDeviceInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#abbbdeee7ba35a6c6e594639a30dcf587">getComputeDevicesOpenCL</a> ()</td></tr>
<tr class="separator:abbbdeee7ba35a6c6e594639a30dcf587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d03c84cc5dd1321fb374c3e505590ec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d03c84cc5dd1321fb374c3e505590ec"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a9d03c84cc5dd1321fb374c3e505590ec">getCropRegion</a> (int &amp;srcWidth, int &amp;srcHeight, float &amp;rgnLeft, float &amp;rgnTop, float &amp;rgnWidth, float &amp;rgnHeight)</td></tr>
<tr class="memdesc:a9d03c84cc5dd1321fb374c3e505590ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the virtual crop region (RgnLeft, RgnTop, RgnWidth, RgnHeigt) within a virtual source image space with sizes SrcWidth, SrcHeight. <br/></td></tr>
<tr class="separator:a9d03c84cc5dd1321fb374c3e505590ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ac5a5025dd6870758a80b021edcf288"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5ac5a5025dd6870758a80b021edcf288"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a5ac5a5025dd6870758a80b021edcf288">getCurrentFrame</a> () const </td></tr>
<tr class="memdesc:a5ac5a5025dd6870758a80b021edcf288"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the currently set animation frame number. This is related to the current scene time through the SettingsOutput.frames_per_second parameter. <br/></td></tr>
<tr class="separator:a5ac5a5025dd6870758a80b021edcf288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4a70c1480c588a602a5a2f4777323b9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab4a70c1480c588a602a5a2f4777323b9"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#ab4a70c1480c588a602a5a2f4777323b9">getCurrentTime</a> () const </td></tr>
<tr class="memdesc:ab4a70c1480c588a602a5a2f4777323b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current scene time. This is related to the current frame number through the SettingsOutput.frames_per_second parameter. <br/></td></tr>
<tr class="separator:ab4a70c1480c588a602a5a2f4777323b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76cc509fdf785a87775e832624f9ecc2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a76cc509fdf785a87775e832624f9ecc2"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a76cc509fdf785a87775e832624f9ecc2">getHeight</a> () const </td></tr>
<tr class="memdesc:a76cc509fdf785a87775e832624f9ecc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the frame buffer height. <br/></td></tr>
<tr class="separator:a76cc509fdf785a87775e832624f9ecc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a433b2c0d6bc6a5cae1f686381c4d71e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_v_ray_1_1_v_ray_image.html">VRayImage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a433b2c0d6bc6a5cae1f686381c4d71e9">getImage</a> () const </td></tr>
<tr class="separator:a433b2c0d6bc6a5cae1f686381c4d71e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a384615b4231c48a2b0f396d42e20d34a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_v_ray_1_1_v_ray_image.html">VRayImage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a384615b4231c48a2b0f396d42e20d34a">getImage</a> (const <a class="el" href="struct_v_ray_1_1_get_image_options.html">GetImageOptions</a> &amp;options) const </td></tr>
<tr class="separator:a384615b4231c48a2b0f396d42e20d34a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9617601331ba43c2f82b867a4e3062c0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9617601331ba43c2f82b867a4e3062c0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a9617601331ba43c2f82b867a4e3062c0">getImageSize</a> (int &amp;width, int &amp;height) const </td></tr>
<tr class="memdesc:a9617601331ba43c2f82b867a4e3062c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the frame buffer width and height. <br/></td></tr>
<tr class="separator:a9617601331ba43c2f82b867a4e3062c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab06480d098351ed0b47029c22ae2e500"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#ab06480d098351ed0b47029c22ae2e500">getInactiveHosts</a> () const </td></tr>
<tr class="separator:ab06480d098351ed0b47029c22ae2e500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08adbdf876087124f9f47aecdad0263b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_v_ray_1_1_plugin.html">Plugin</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a08adbdf876087124f9f47aecdad0263b">getInstanceOf</a> (const char *pluginType) const </td></tr>
<tr class="separator:a08adbdf876087124f9f47aecdad0263b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb42abb13ce1bcbbc6ea45f67178596e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_v_ray_1_1_plugin.html">Plugin</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#abb42abb13ce1bcbbc6ea45f67178596e">getInstanceOf</a> (const std::string &amp;pluginType) const </td></tr>
<tr class="separator:abb42abb13ce1bcbbc6ea45f67178596e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a216660b6220fd2c068f16afb69c30131"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a216660b6220fd2c068f16afb69c30131"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a216660b6220fd2c068f16afb69c30131">getInstanceOf</a> () const </td></tr>
<tr class="separator:a216660b6220fd2c068f16afb69c30131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a710f9e9244a0b39e2e16a3b49cc788ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_v_ray_1_1_plugin.html">Plugin</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a710f9e9244a0b39e2e16a3b49cc788ca">getInstanceOrCreate</a> (const char *pluginType)</td></tr>
<tr class="separator:a710f9e9244a0b39e2e16a3b49cc788ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2595cafce1c8423ac1042fdaaddfe54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_v_ray_1_1_plugin.html">Plugin</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#ae2595cafce1c8423ac1042fdaaddfe54">getInstanceOrCreate</a> (const std::string &amp;pluginType)</td></tr>
<tr class="separator:ae2595cafce1c8423ac1042fdaaddfe54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0f92773090da07d04bd6f0d13c53c07"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ac0f92773090da07d04bd6f0d13c53c07"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#ac0f92773090da07d04bd6f0d13c53c07">getInstanceOrCreate</a> ()</td></tr>
<tr class="separator:ac0f92773090da07d04bd6f0d13c53c07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24d319d0406139703baefb026ca9da05"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_v_ray_1_1_plugin.html">Plugin</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a24d319d0406139703baefb026ca9da05">getInstanceOrCreate</a> (const char *pluginName, const char *pluginType)</td></tr>
<tr class="separator:a24d319d0406139703baefb026ca9da05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e76ec9948dff5619813d7e87b73e2fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_v_ray_1_1_plugin.html">Plugin</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a9e76ec9948dff5619813d7e87b73e2fe">getInstanceOrCreate</a> (const std::string &amp;pluginName, const char *pluginType)</td></tr>
<tr class="separator:a9e76ec9948dff5619813d7e87b73e2fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a869f5b94e8e22647bd3f661b8d401f85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_v_ray_1_1_plugin.html">Plugin</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a869f5b94e8e22647bd3f661b8d401f85">getInstanceOrCreate</a> (const char *pluginName, const std::string &amp;pluginType)</td></tr>
<tr class="separator:a869f5b94e8e22647bd3f661b8d401f85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80011c6e6556c31efac04b345aa9bffd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_v_ray_1_1_plugin.html">Plugin</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a80011c6e6556c31efac04b345aa9bffd">getInstanceOrCreate</a> (const std::string &amp;pluginName, const std::string &amp;pluginType)</td></tr>
<tr class="separator:a80011c6e6556c31efac04b345aa9bffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a479b02ee4628bce12db3e61fa5990f81"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a479b02ee4628bce12db3e61fa5990f81"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a479b02ee4628bce12db3e61fa5990f81">getInstanceOrCreate</a> (const char *pluginName)</td></tr>
<tr class="separator:a479b02ee4628bce12db3e61fa5990f81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16965b7419e39b199b31c5fdb029db7b"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a16965b7419e39b199b31c5fdb029db7b"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a16965b7419e39b199b31c5fdb029db7b">getInstanceOrCreate</a> (const std::string &amp;pluginName)</td></tr>
<tr class="separator:a16965b7419e39b199b31c5fdb029db7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac218ba0d12009938d45d60a2b51ed9f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#aac218ba0d12009938d45d60a2b51ed9f">getIrradianceMapSize</a> ()</td></tr>
<tr class="separator:aac218ba0d12009938d45d60a2b51ed9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e162e2277748e2a68fbb81f1218cf9d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9e162e2277748e2a68fbb81f1218cf9d"></a>
<a class="el" href="class_v_ray_1_1_error.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a9e162e2277748e2a68fbb81f1218cf9d">getLastError</a> () const </td></tr>
<tr class="memdesc:a9e162e2277748e2a68fbb81f1218cf9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the last error that occurred when a method was called. Use this to understand why a method returned false. <br/></td></tr>
<tr class="separator:a9e162e2277748e2a68fbb81f1218cf9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5df8e0d290de1d52f6e19751a48f92c2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5df8e0d290de1d52f6e19751a48f92c2"></a>
<a class="el" href="struct_v_ray_1_1_parser_error.html">ParserError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a5df8e0d290de1d52f6e19751a48f92c2">getLastParserError</a> () const </td></tr>
<tr class="memdesc:a5df8e0d290de1d52f6e19751a48f92c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the parser error that occurred when a scene was last loaded or appended. <br/></td></tr>
<tr class="separator:a5df8e0d290de1d52f6e19751a48f92c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9abae640b0b88887eaae9c1f04c90f4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa9abae640b0b88887eaae9c1f04c90f4"></a>
<a class="el" href="union_v_ray_1_1_license_error.html">LicenseError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#aa9abae640b0b88887eaae9c1f04c90f4">getLicenseError</a> () const </td></tr>
<tr class="memdesc:aa9abae640b0b88887eaae9c1f04c90f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the license error (if any) that occurred when the renderer was constructed or when rendering was started. <br/></td></tr>
<tr class="separator:aa9abae640b0b88887eaae9c1f04c90f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1233f32aa8a7f86b00e8012d84c29064"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a1233f32aa8a7f86b00e8012d84c29064">getLightCacheSize</a> ()</td></tr>
<tr class="separator:a1233f32aa8a7f86b00e8012d84c29064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a483767ddcd8faf4555607dc24ea5f479"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a483767ddcd8faf4555607dc24ea5f479"></a>
<a class="el" href="struct_v_ray_1_1_renderer_options.html">RendererOptions</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a483767ddcd8faf4555607dc24ea5f479">getOptions</a> ()</td></tr>
<tr class="memdesc:a483767ddcd8faf4555607dc24ea5f479"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the currently used options. <br/></td></tr>
<tr class="separator:a483767ddcd8faf4555607dc24ea5f479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5093e03131eca8fc961cf136b438fb04"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_v_ray_1_1_plugin.html">Plugin</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a5093e03131eca8fc961cf136b438fb04">getOrCreatePlugin</a> (const char *pluginName, const char *pluginType)</td></tr>
<tr class="separator:a5093e03131eca8fc961cf136b438fb04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae30fd2c65ab6a1bcd5478975bdf5b4a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_v_ray_1_1_plugin.html">Plugin</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#ae30fd2c65ab6a1bcd5478975bdf5b4a7">getOrCreatePlugin</a> (const std::string &amp;pluginName, const char *pluginType)</td></tr>
<tr class="separator:ae30fd2c65ab6a1bcd5478975bdf5b4a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac75c04515d971dba592f7d0a0591179e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_v_ray_1_1_plugin.html">Plugin</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#ac75c04515d971dba592f7d0a0591179e">getOrCreatePlugin</a> (const char *pluginName, const std::string &amp;pluginType)</td></tr>
<tr class="separator:ac75c04515d971dba592f7d0a0591179e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadec07432c6d3b1d14cd9809815cb7a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_v_ray_1_1_plugin.html">Plugin</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#aadec07432c6d3b1d14cd9809815cb7a0">getOrCreatePlugin</a> (const std::string &amp;pluginName, const std::string &amp;pluginType)</td></tr>
<tr class="separator:aadec07432c6d3b1d14cd9809815cb7a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10c2630eb675945b82a01b94ae4a0bab"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a10c2630eb675945b82a01b94ae4a0bab"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a10c2630eb675945b82a01b94ae4a0bab">getOrCreatePlugin</a> (const char *pluginName)</td></tr>
<tr class="separator:a10c2630eb675945b82a01b94ae4a0bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bee46faa649e74b2aaad7d7359e9846"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a9bee46faa649e74b2aaad7d7359e9846">getPhotonMapSize</a> ()</td></tr>
<tr class="separator:a9bee46faa649e74b2aaad7d7359e9846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5258af41f75dbc92d5945c3cc84eca83"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_v_ray_1_1_plugin.html">Plugin</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a5258af41f75dbc92d5945c3cc84eca83">getPlugin</a> (const char *pluginName) const </td></tr>
<tr class="separator:a5258af41f75dbc92d5945c3cc84eca83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31659ad9a9cbce9b04af0fe13fff61a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_v_ray_1_1_plugin.html">Plugin</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a31659ad9a9cbce9b04af0fe13fff61a3">getPlugin</a> (const std::string &amp;pluginName) const </td></tr>
<tr class="separator:a31659ad9a9cbce9b04af0fe13fff61a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43c1b9915eaa193a1e37deffbd23ac74"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a43c1b9915eaa193a1e37deffbd23ac74"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a43c1b9915eaa193a1e37deffbd23ac74">getPlugin</a> (const char *pluginName) const </td></tr>
<tr class="separator:a43c1b9915eaa193a1e37deffbd23ac74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99ddd33a9d1bc06a0b641b7ca8c21276"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a99ddd33a9d1bc06a0b641b7ca8c21276"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a99ddd33a9d1bc06a0b641b7ca8c21276">getPlugin</a> (const std::string &amp;pluginName) const </td></tr>
<tr class="separator:a99ddd33a9d1bc06a0b641b7ca8c21276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab444bd286df3130aadea3fd465495187"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab444bd286df3130aadea3fd465495187"></a>
<a class="el" href="class_v_ray_1_1_plugin_meta.html">PluginMeta</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#ab444bd286df3130aadea3fd465495187">getPluginMeta</a> (const std::string &amp;pluginClassName) const </td></tr>
<tr class="memdesc:ab444bd286df3130aadea3fd465495187"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return static meta information about a given plugin type. <br/></td></tr>
<tr class="separator:ab444bd286df3130aadea3fd465495187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3c1bfa088f231cdf76ae8bbb00da600"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac3c1bfa088f231cdf76ae8bbb00da600"></a>
std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#ac3c1bfa088f231cdf76ae8bbb00da600">getPluginNames</a> () const </td></tr>
<tr class="memdesc:ac3c1bfa088f231cdf76ae8bbb00da600"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the names of all V-Ray plugin instances existing in the current scene. <br/></td></tr>
<tr class="separator:ac3c1bfa088f231cdf76ae8bbb00da600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48526b1e16a4a975689f47b864cc0cf8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a48526b1e16a4a975689f47b864cc0cf8"></a>
std::vector&lt; <a class="el" href="class_v_ray_1_1_plugin.html">Plugin</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a48526b1e16a4a975689f47b864cc0cf8">getPlugins</a> () const </td></tr>
<tr class="memdesc:a48526b1e16a4a975689f47b864cc0cf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all plugin instances in the current scene. <br/></td></tr>
<tr class="separator:a48526b1e16a4a975689f47b864cc0cf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82ed7ac6e1da158163c8549003d653c2"><td class="memTemplParams" colspan="2"><a class="anchor" id="a82ed7ac6e1da158163c8549003d653c2"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a82ed7ac6e1da158163c8549003d653c2"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a82ed7ac6e1da158163c8549003d653c2">getPlugins</a> () const </td></tr>
<tr class="memdesc:a82ed7ac6e1da158163c8549003d653c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all plugin instances of a given type T in the current scene. <br/></td></tr>
<tr class="separator:a82ed7ac6e1da158163c8549003d653c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaab4ebeb52130cd42921b113303e72ec"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_v_ray_1_1_plugin.html">Plugin</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#aaab4ebeb52130cd42921b113303e72ec">getPlugins</a> (const char *pluginClassName) const </td></tr>
<tr class="separator:aaab4ebeb52130cd42921b113303e72ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac0e0d149298a1198b6afd576a7e61d9"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_v_ray_1_1_plugin.html">Plugin</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#aac0e0d149298a1198b6afd576a7e61d9">getPlugins</a> (const std::string &amp;pluginClassName) const </td></tr>
<tr class="separator:aac0e0d149298a1198b6afd576a7e61d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ee8cb9626a9170df1603e44eb2f0331"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2ee8cb9626a9170df1603e44eb2f0331"></a>
<a class="el" href="class_v_ray_1_1_render_elements.html">RenderElements</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a2ee8cb9626a9170df1603e44eb2f0331">getRenderElements</a> ()</td></tr>
<tr class="memdesc:a2ee8cb9626a9170df1603e44eb2f0331"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an object that groups render element management methods. <br/></td></tr>
<tr class="separator:a2ee8cb9626a9170df1603e44eb2f0331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abad3ae87da3b7fdf93d5a1b4728e2f02"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abad3ae87da3b7fdf93d5a1b4728e2f02"></a>
RendererOptions::RenderMode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#abad3ae87da3b7fdf93d5a1b4728e2f02">getRenderMode</a> ()</td></tr>
<tr class="memdesc:abad3ae87da3b7fdf93d5a1b4728e2f02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current render mode. <br/></td></tr>
<tr class="separator:abad3ae87da3b7fdf93d5a1b4728e2f02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a774aebbb18ac28bb080f3f25224d4c77"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a774aebbb18ac28bb080f3f25224d4c77">getRenderRegion</a> (int &amp;rgnLeft, int &amp;rgnTop, int &amp;rgnWidth, int &amp;rgnHeight)</td></tr>
<tr class="separator:a774aebbb18ac28bb080f3f25224d4c77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc5ba1fdb32e033d5fc456343287d8d3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acc5ba1fdb32e033d5fc456343287d8d3"></a>
<a class="el" href="struct_v_ray_1_1_r_t_statistics.html">RTStatistics</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#acc5ba1fdb32e033d5fc456343287d8d3">getRTStatistics</a> () const </td></tr>
<tr class="memdesc:acc5ba1fdb32e033d5fc456343287d8d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns some performance statistics from the RT engine. <br/></td></tr>
<tr class="separator:acc5ba1fdb32e033d5fc456343287d8d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac55c4cca9d9397c9e8b482cdd4780719"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac55c4cca9d9397c9e8b482cdd4780719"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#ac55c4cca9d9397c9e8b482cdd4780719">getSequenceFrame</a> () const </td></tr>
<tr class="memdesc:ac55c4cca9d9397c9e8b482cdd4780719"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current frame number while rendering a sequence. <br/></td></tr>
<tr class="separator:ac55c4cca9d9397c9e8b482cdd4780719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5c4e0269527ae1c52bb372210a1ea4c"><td class="memItemLeft" align="right" valign="top">RendererState&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#ab5c4e0269527ae1c52bb372210a1ea4c">getState</a> () const </td></tr>
<tr class="separator:ab5c4e0269527ae1c52bb372210a1ea4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4ccf84a842beda8997ca5817b15eace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af4ccf84a842beda8997ca5817b15eace"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#af4ccf84a842beda8997ca5817b15eace">getUseAnimatedValuesState</a> () const </td></tr>
<tr class="memdesc:af4ccf84a842beda8997ca5817b15eace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if setting parameter values adds keyframes and false if it overwrites. <br/></td></tr>
<tr class="separator:af4ccf84a842beda8997ca5817b15eace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4de08047a33b7241d6075c21549af2b3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4de08047a33b7241d6075c21549af2b3"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a4de08047a33b7241d6075c21549af2b3">getWidth</a> () const </td></tr>
<tr class="memdesc:a4de08047a33b7241d6075c21549af2b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the frame buffer width. <br/></td></tr>
<tr class="separator:a4de08047a33b7241d6075c21549af2b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a966c91d52a74e1730196dd77490cd6b0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a966c91d52a74e1730196dd77490cd6b0">isAborted</a> () const </td></tr>
<tr class="separator:a966c91d52a74e1730196dd77490cd6b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67aff084d561a4177434a04891d6db1a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a67aff084d561a4177434a04891d6db1a">isImageReady</a> () const </td></tr>
<tr class="separator:a67aff084d561a4177434a04891d6db1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37b4f4988009867a30bfabe54a4271b0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a37b4f4988009867a30bfabe54a4271b0">isSequenceDone</a> () const </td></tr>
<tr class="separator:a37b4f4988009867a30bfabe54a4271b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a36db37a7b22494ff7d2fd85b39c9fe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a2a36db37a7b22494ff7d2fd85b39c9fe">load</a> (const char *fileName) const </td></tr>
<tr class="separator:a2a36db37a7b22494ff7d2fd85b39c9fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a113c43b383295d0b4821618aa10aeaa7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a113c43b383295d0b4821618aa10aeaa7">load</a> (const std::string &amp;fileName) const </td></tr>
<tr class="separator:a113c43b383295d0b4821618aa10aeaa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8ea5a15de2b05802a6280cdd67ce795"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#af8ea5a15de2b05802a6280cdd67ce795">loadAsText</a> (const char *text) const </td></tr>
<tr class="separator:af8ea5a15de2b05802a6280cdd67ce795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d6b2797472bb0a4ba499ac8af8d5c86"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a4d6b2797472bb0a4ba499ac8af8d5c86">loadAsText</a> (const std::string &amp;text) const </td></tr>
<tr class="separator:a4d6b2797472bb0a4ba499ac8af8d5c86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d47f7ef848907ffab753ad8f85b3a4f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a1d47f7ef848907ffab753ad8f85b3a4f">loadAsTextFiltered</a> (const char *fileName, bool(*callback)(<a class="el" href="class_v_ray_1_1_v_ray_renderer.html">VRayRenderer</a> &amp;, const char *pluginType, std::string &amp;pluginName, void *), const void *userData=NULL)</td></tr>
<tr class="separator:a1d47f7ef848907ffab753ad8f85b3a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57d05df739683ad6ec5370042e115efb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a57d05df739683ad6ec5370042e115efb">loadAsTextFiltered</a> (const std::string &amp;fileName, bool(*callback)(<a class="el" href="class_v_ray_1_1_v_ray_renderer.html">VRayRenderer</a> &amp;, const char *pluginType, std::string &amp;pluginName, void *), const void *userData=NULL)</td></tr>
<tr class="separator:a57d05df739683ad6ec5370042e115efb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0692856bcb43b792a8fdd631ccf01e1e"><td class="memTemplParams" colspan="2">template&lt;class T , bool(T::*)(VRayRenderer &amp;, const char *pluginType, std::string &amp;pluginName, void *) TMethod&gt; </td></tr>
<tr class="memitem:a0692856bcb43b792a8fdd631ccf01e1e"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a0692856bcb43b792a8fdd631ccf01e1e">loadAsTextFiltered</a> (const char *fileName, T &amp;obj, const void *userData=NULL)</td></tr>
<tr class="separator:a0692856bcb43b792a8fdd631ccf01e1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49391df3c350bdff45f39b8961f455ba"><td class="memTemplParams" colspan="2">template&lt;class T , bool(T::*)(VRayRenderer &amp;, const char *pluginType, std::string &amp;pluginName, void *) TMethod&gt; </td></tr>
<tr class="memitem:a49391df3c350bdff45f39b8961f455ba"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a49391df3c350bdff45f39b8961f455ba">loadAsTextFiltered</a> (const std::string &amp;fileName, T &amp;obj, const void *userData=NULL)</td></tr>
<tr class="separator:a49391df3c350bdff45f39b8961f455ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa24f282ac349c21afaf5ed756c9c77de"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#aa24f282ac349c21afaf5ed756c9c77de">loadFiltered</a> (const char *fileName, bool(*callback)(<a class="el" href="class_v_ray_1_1_v_ray_renderer.html">VRayRenderer</a> &amp;, const char *pluginType, std::string &amp;pluginName, void *), const void *userData=NULL)</td></tr>
<tr class="separator:aa24f282ac349c21afaf5ed756c9c77de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7933067177d5ab27153b857bc905eed"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#ab7933067177d5ab27153b857bc905eed">loadFiltered</a> (const std::string &amp;fileName, bool(*callback)(<a class="el" href="class_v_ray_1_1_v_ray_renderer.html">VRayRenderer</a> &amp;, const char *pluginType, std::string &amp;pluginName, void *), const void *userData=NULL)</td></tr>
<tr class="separator:ab7933067177d5ab27153b857bc905eed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7c4add2a63195cd912cd0da2159194c"><td class="memTemplParams" colspan="2">template&lt;class T , bool(T::*)(VRayRenderer &amp;, const char *pluginType, std::string &amp;pluginName, void *) TMethod&gt; </td></tr>
<tr class="memitem:ac7c4add2a63195cd912cd0da2159194c"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#ac7c4add2a63195cd912cd0da2159194c">loadFiltered</a> (const char *fileName, T &amp;obj, const void *userData=NULL)</td></tr>
<tr class="separator:ac7c4add2a63195cd912cd0da2159194c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1201854b2554a938d6e62348bc48a8f"><td class="memTemplParams" colspan="2">template&lt;class T , bool(T::*)(VRayRenderer &amp;, const char *pluginType, std::string &amp;pluginName, void *) TMethod&gt; </td></tr>
<tr class="memitem:af1201854b2554a938d6e62348bc48a8f"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#af1201854b2554a938d6e62348bc48a8f">loadFiltered</a> (const std::string &amp;fileName, T &amp;obj, const void *userData=NULL)</td></tr>
<tr class="separator:af1201854b2554a938d6e62348bc48a8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4229096092ef1f136416c57b23c6dee4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_v_ray_1_1_plugin.html">Plugin</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a4229096092ef1f136416c57b23c6dee4">newPlugin</a> (const char *pluginName, const char *pluginType)</td></tr>
<tr class="separator:a4229096092ef1f136416c57b23c6dee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab392b36cd7dff6d95a630b448369a204"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_v_ray_1_1_plugin.html">Plugin</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#ab392b36cd7dff6d95a630b448369a204">newPlugin</a> (const std::string &amp;pluginName, const std::string &amp;pluginType)</td></tr>
<tr class="separator:ab392b36cd7dff6d95a630b448369a204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcc13be418f1e76bf8238aec79701d42"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_v_ray_1_1_plugin.html">Plugin</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#adcc13be418f1e76bf8238aec79701d42">newPlugin</a> (const char *pluginName, const std::string &amp;pluginType)</td></tr>
<tr class="separator:adcc13be418f1e76bf8238aec79701d42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab405aa3163d6d27cb2e76372f17a702e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_v_ray_1_1_plugin.html">Plugin</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#ab405aa3163d6d27cb2e76372f17a702e">newPlugin</a> (const std::string &amp;pluginName, const char *pluginType)</td></tr>
<tr class="separator:ab405aa3163d6d27cb2e76372f17a702e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a668726573f9683584db2d0552abdf092"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a668726573f9683584db2d0552abdf092"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a668726573f9683584db2d0552abdf092">newPlugin</a> (const char *pluginName)</td></tr>
<tr class="separator:a668726573f9683584db2d0552abdf092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5bc74e164a1aa9132d4c0b0f10427f5"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ae5bc74e164a1aa9132d4c0b0f10427f5"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#ae5bc74e164a1aa9132d4c0b0f10427f5">newPlugin</a> (const std::string &amp;pluginName)</td></tr>
<tr class="separator:ae5bc74e164a1aa9132d4c0b0f10427f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e059ebd191ddafdb66872db3b904148"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_v_ray_1_1_plugin.html">Plugin</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a3e059ebd191ddafdb66872db3b904148">newPlugin</a> (const char *pluginType)</td></tr>
<tr class="separator:a3e059ebd191ddafdb66872db3b904148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77d134d37a20a20188c898a750b198c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_v_ray_1_1_plugin.html">Plugin</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a77d134d37a20a20188c898a750b198c3">newPlugin</a> (const std::string &amp;pluginType)</td></tr>
<tr class="separator:a77d134d37a20a20188c898a750b198c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac92514f42ebe4bb9d2b54eb227ecd94d"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ac92514f42ebe4bb9d2b54eb227ecd94d"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#ac92514f42ebe4bb9d2b54eb227ecd94d">newPlugin</a> ()</td></tr>
<tr class="separator:ac92514f42ebe4bb9d2b54eb227ecd94d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11136843d8dbfa656c5b5f3f02989199"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a11136843d8dbfa656c5b5f3f02989199">operator bool</a> () const </td></tr>
<tr class="separator:a11136843d8dbfa656c5b5f3f02989199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48a9ee38bafd3d6e57f4032c26daac88"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a48a9ee38bafd3d6e57f4032c26daac88"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a48a9ee38bafd3d6e57f4032c26daac88">pause</a> () const </td></tr>
<tr class="memdesc:a48a9ee38bafd3d6e57f4032c26daac88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pauses RT rendering. Only sampling is stopped, so that the CPU/GPU will be idle, but everything else is the same. <br/></td></tr>
<tr class="separator:a48a9ee38bafd3d6e57f4032c26daac88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72045eeaa88d855a505216c87a05822d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_v_ray_1_1_plugin.html">Plugin</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a72045eeaa88d855a505216c87a05822d">pickPlugin</a> (int x, int y) const </td></tr>
<tr class="separator:a72045eeaa88d855a505216c87a05822d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacd27088c3c6f2b56db0ff2688a5bed8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_v_ray_1_1_plugin.html">Plugin</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#aacd27088c3c6f2b56db0ff2688a5bed8">pickPlugin</a> (int x, int y, int timeout) const </td></tr>
<tr class="separator:aacd27088c3c6f2b56db0ff2688a5bed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a38dd2e14ca6a5aa9f1b3660f02601c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="struct_v_ray_1_1_plugin_distance_pair.html">PluginDistancePair</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a1a38dd2e14ca6a5aa9f1b3660f02601c">pickPlugins</a> (double x, double y, int maxcount=0, int timeout=-1) const </td></tr>
<tr class="separator:a1a38dd2e14ca6a5aa9f1b3660f02601c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab04696524b30104dfdbfbfe010164bb4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#ab04696524b30104dfdbfbfe010164bb4">pluginExists</a> (const char *pluginName) const </td></tr>
<tr class="separator:ab04696524b30104dfdbfbfe010164bb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d53afa95c08290c2bb1112e496af1eb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a5d53afa95c08290c2bb1112e496af1eb">pluginExists</a> (const std::string &amp;pluginName) const </td></tr>
<tr class="separator:a5d53afa95c08290c2bb1112e496af1eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a560b74d4e4b2775fd0d188ae658b87e2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a560b74d4e4b2775fd0d188ae658b87e2">readProxyFullData</a> (const <a class="el" href="class_v_ray_1_1_plugin.html">Plugin</a> &amp;proxyPlugin, <a class="el" href="class_v_ray_1_1_proxy_read_data.html">ProxyReadData</a> &amp;readData) const </td></tr>
<tr class="separator:a560b74d4e4b2775fd0d188ae658b87e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad32e0cfdc64ceabcdcf5d2f52c8eded9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#ad32e0cfdc64ceabcdcf5d2f52c8eded9">readProxyPreviewGeometry</a> (const <a class="el" href="class_v_ray_1_1_plugin.html">Plugin</a> &amp;proxyPlugin, VectorList &amp;vertices, IntList &amp;indices, int countHint=0) const </td></tr>
<tr class="separator:ad32e0cfdc64ceabcdcf5d2f52c8eded9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af54ed5c48c75b77d2680de9ff8f0bb7e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#af54ed5c48c75b77d2680de9ff8f0bb7e">readProxyPreviewHair</a> (const <a class="el" href="class_v_ray_1_1_plugin.html">Plugin</a> &amp;proxyPlugin, VectorList &amp;vertices, IntList &amp;lengths, int countHint=0) const </td></tr>
<tr class="separator:af54ed5c48c75b77d2680de9ff8f0bb7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52549b385db790505fcad4ca87d2bb09"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a52549b385db790505fcad4ca87d2bb09">readProxyPreviewParticles</a> (const <a class="el" href="class_v_ray_1_1_plugin.html">Plugin</a> &amp;proxyPlugin, VectorList &amp;positions, int countHint=0) const </td></tr>
<tr class="separator:a52549b385db790505fcad4ca87d2bb09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57b5c2de16f23c90b541a38e2606be36"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a57b5c2de16f23c90b541a38e2606be36">removeHosts</a> (const char *hosts) const </td></tr>
<tr class="separator:a57b5c2de16f23c90b541a38e2606be36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae850e272778f838de4a46410fc51d245"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#ae850e272778f838de4a46410fc51d245">removeHosts</a> (const std::string &amp;hosts) const </td></tr>
<tr class="separator:ae850e272778f838de4a46410fc51d245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2fa24e78b2140c3c45732d3f778469c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#ac2fa24e78b2140c3c45732d3f778469c">removePlugin</a> (const <a class="el" href="class_v_ray_1_1_plugin.html">Plugin</a> &amp;plugin)</td></tr>
<tr class="separator:ac2fa24e78b2140c3c45732d3f778469c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2f6182012fa704641e25071c2c872d1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#aa2f6182012fa704641e25071c2c872d1">removePlugin</a> (const std::string &amp;pluginName)</td></tr>
<tr class="separator:aa2f6182012fa704641e25071c2c872d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16218b4522c7997f3c02d4d3200619b9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a16218b4522c7997f3c02d4d3200619b9">removePlugin</a> (const char *pluginName)</td></tr>
<tr class="separator:a16218b4522c7997f3c02d4d3200619b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a813944b6c7f34a3a7f6584d960c5a93f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a813944b6c7f34a3a7f6584d960c5a93f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a813944b6c7f34a3a7f6584d960c5a93f">renderSequence</a> () const </td></tr>
<tr class="memdesc:a813944b6c7f34a3a7f6584d960c5a93f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins rendering an animation sequence in a separate thread. A non-blocking call. <br/></td></tr>
<tr class="separator:a813944b6c7f34a3a7f6584d960c5a93f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac871054ee4cae5148298abc8da5aae4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#aac871054ee4cae5148298abc8da5aae4">renderSequence</a> (<a class="el" href="struct_v_ray_1_1_sub_sequence_desc.html">SubSequenceDesc</a> descriptions[], size_t count) const </td></tr>
<tr class="separator:aac871054ee4cae5148298abc8da5aae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaac68504d2fc4c9189a1c483469eb8b0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#aaac68504d2fc4c9189a1c483469eb8b0">replacePlugin</a> (const <a class="el" href="class_v_ray_1_1_plugin.html">Plugin</a> &amp;oldPlugin, const <a class="el" href="class_v_ray_1_1_plugin.html">Plugin</a> &amp;<a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a4229096092ef1f136416c57b23c6dee4">newPlugin</a>)</td></tr>
<tr class="separator:aaac68504d2fc4c9189a1c483469eb8b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d0cd25ff4a55c35c5f403ff535ac4a8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2d0cd25ff4a55c35c5f403ff535ac4a8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a2d0cd25ff4a55c35c5f403ff535ac4a8">reset</a> ()</td></tr>
<tr class="memdesc:a2d0cd25ff4a55c35c5f403ff535ac4a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops any ongoing rendering and clears the scene contents. This is similar to creating a new renderer with the same options. <br/></td></tr>
<tr class="separator:a2d0cd25ff4a55c35c5f403ff535ac4a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab589781ee11684209d771fc98d7ce910"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab589781ee11684209d771fc98d7ce910"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#ab589781ee11684209d771fc98d7ce910">reset</a> (const <a class="el" href="struct_v_ray_1_1_renderer_options.html">RendererOptions</a> &amp;options)</td></tr>
<tr class="memdesc:ab589781ee11684209d771fc98d7ce910"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops any ongoing rendering and clears the scene contents. This is similar to creating a new renderer with the newly passed options. <br/></td></tr>
<tr class="separator:ab589781ee11684209d771fc98d7ce910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32e571b68b8de7ab23463a8258797c7c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a32e571b68b8de7ab23463a8258797c7c">resetHosts</a> (const char *hosts=NULL) const </td></tr>
<tr class="separator:a32e571b68b8de7ab23463a8258797c7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73b6045d3aa3227e033f7d90dc2e3263"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a73b6045d3aa3227e033f7d90dc2e3263">resetHosts</a> (const std::string &amp;hosts) const </td></tr>
<tr class="separator:a73b6045d3aa3227e033f7d90dc2e3263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff3f31d4053d2a2cc48073c4e8f0f411"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aff3f31d4053d2a2cc48073c4e8f0f411"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#aff3f31d4053d2a2cc48073c4e8f0f411">resume</a> () const </td></tr>
<tr class="memdesc:aff3f31d4053d2a2cc48073c4e8f0f411"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resumes RT rendering. <br/></td></tr>
<tr class="separator:aff3f31d4053d2a2cc48073c4e8f0f411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55999e7633f3d160de4e8aed7c4917fd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a55999e7633f3d160de4e8aed7c4917fd">saveCausticsFile</a> (const std::string &amp;fileName)</td></tr>
<tr class="separator:a55999e7633f3d160de4e8aed7c4917fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a448af494ba7ff2f82cc99f3cd6bba381"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a448af494ba7ff2f82cc99f3cd6bba381">saveCausticsFile</a> (const char *fileName)</td></tr>
<tr class="separator:a448af494ba7ff2f82cc99f3cd6bba381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdf58f4321b4eac46bbc10ba5e8913f0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#abdf58f4321b4eac46bbc10ba5e8913f0">saveImage</a> (const char *fileName) const </td></tr>
<tr class="separator:abdf58f4321b4eac46bbc10ba5e8913f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a541585be484094b0e669c912549ba016"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a541585be484094b0e669c912549ba016">saveImage</a> (const std::string &amp;fileName) const </td></tr>
<tr class="separator:a541585be484094b0e669c912549ba016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7232bc1626c85e5124b2a6039c7e59ff"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a7232bc1626c85e5124b2a6039c7e59ff">saveImage</a> (const char *fileName, const <a class="el" href="struct_v_ray_1_1_image_writer_options.html">ImageWriterOptions</a> &amp;options) const </td></tr>
<tr class="separator:a7232bc1626c85e5124b2a6039c7e59ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a585e64ae8f0718481023362c3f626104"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a585e64ae8f0718481023362c3f626104">saveImage</a> (const std::string &amp;fileName, const <a class="el" href="struct_v_ray_1_1_image_writer_options.html">ImageWriterOptions</a> &amp;options) const </td></tr>
<tr class="separator:a585e64ae8f0718481023362c3f626104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf676993996bc2bebe41de6faea487fa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#abf676993996bc2bebe41de6faea487fa">saveIrradianceMapFile</a> (const std::string &amp;fileName)</td></tr>
<tr class="separator:abf676993996bc2bebe41de6faea487fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf83cb79f4912586c7c4982a82cedc28"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#acf83cb79f4912586c7c4982a82cedc28">saveIrradianceMapFile</a> (const char *fileName)</td></tr>
<tr class="separator:acf83cb79f4912586c7c4982a82cedc28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eb353f94a5b7969bab4c68d8b683f6b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a5eb353f94a5b7969bab4c68d8b683f6b">saveLightCacheFile</a> (const std::string &amp;fileName)</td></tr>
<tr class="separator:a5eb353f94a5b7969bab4c68d8b683f6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad7e691810211b102d26fd08d79ea040"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#aad7e691810211b102d26fd08d79ea040">saveLightCacheFile</a> (const char *fileName)</td></tr>
<tr class="separator:aad7e691810211b102d26fd08d79ea040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4287d85bc13e4c7d96be3a86cc53918"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#aa4287d85bc13e4c7d96be3a86cc53918">savePhotonMapFile</a> (const std::string &amp;fileName)</td></tr>
<tr class="separator:aa4287d85bc13e4c7d96be3a86cc53918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16eeda5b462c42f16ef936e7e3c21187"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a16eeda5b462c42f16ef936e7e3c21187">savePhotonMapFile</a> (const char *fileName)</td></tr>
<tr class="separator:a16eeda5b462c42f16ef936e7e3c21187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a624e6cef1e64fa632e8676864470fa54"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a624e6cef1e64fa632e8676864470fa54">serializeScene</a> ()</td></tr>
<tr class="separator:a624e6cef1e64fa632e8676864470fa54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac30e6eabda89b6b2ae078d664a3b40bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#ac30e6eabda89b6b2ae078d664a3b40bd">setAutoCommit</a> (bool autoCommit)</td></tr>
<tr class="separator:ac30e6eabda89b6b2ae078d664a3b40bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee73eb4931a7639f96c973f44e956243"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#aee73eb4931a7639f96c973f44e956243">setCamera</a> (const <a class="el" href="class_v_ray_1_1_plugin.html">Plugin</a> &amp;plugin)</td></tr>
<tr class="separator:aee73eb4931a7639f96c973f44e956243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebe9759517bb0e2c6420ced4223a5574"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#aebe9759517bb0e2c6420ced4223a5574">setComputeDevicesCUDA</a> (const std::vector&lt; int &gt; &amp;indices)</td></tr>
<tr class="separator:aebe9759517bb0e2c6420ced4223a5574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1bc661c508bc732e06cc67d1294d0a5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#ab1bc661c508bc732e06cc67d1294d0a5">setComputeDevicesCurrentEngine</a> (const std::vector&lt; int &gt; &amp;indices)</td></tr>
<tr class="separator:ab1bc661c508bc732e06cc67d1294d0a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0b194091a844ee49c9c0c83e6711994"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#ad0b194091a844ee49c9c0c83e6711994">setComputeDevicesOpenCL</a> (const std::vector&lt; int &gt; &amp;indices)</td></tr>
<tr class="separator:ad0b194091a844ee49c9c0c83e6711994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4c7f41b41cbeb0725119dc8964bce8f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#af4c7f41b41cbeb0725119dc8964bce8f">setCropRegion</a> (int srcWidth, int srcHeight, float rgnLeft, float rgnTop)</td></tr>
<tr class="separator:af4c7f41b41cbeb0725119dc8964bce8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4181fd13621cbc029a22a2f82ebf069"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#aa4181fd13621cbc029a22a2f82ebf069">setCropRegion</a> (int srcWidth, int srcHeight, float rgnLeft, float rgnTop, float rgnWidth, float rgnHeight)</td></tr>
<tr class="separator:aa4181fd13621cbc029a22a2f82ebf069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afad2832c160b1760dab59c0cea2a11e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#afad2832c160b1760dab59c0cea2a11e0">setCurrentFrame</a> (int frame)</td></tr>
<tr class="separator:afad2832c160b1760dab59c0cea2a11e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c15785402cf5ad1c20bde39811a6407"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c15785402cf5ad1c20bde39811a6407"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a8c15785402cf5ad1c20bde39811a6407">setCurrentTime</a> (double time)</td></tr>
<tr class="memdesc:a8c15785402cf5ad1c20bde39811a6407"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the current scene time. This is related to the current frame number through the SettingsOutput.frames_per_second parameter. <br/></td></tr>
<tr class="separator:a8c15785402cf5ad1c20bde39811a6407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3951ae1cd3580bcef46d3fc444dbdd73"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3951ae1cd3580bcef46d3fc444dbdd73"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a3951ae1cd3580bcef46d3fc444dbdd73">setHeight</a> (int height, bool resetCropRegion=true, bool resetRenderRegion=true)</td></tr>
<tr class="memdesc:a3951ae1cd3580bcef46d3fc444dbdd73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the frame buffer height. <br/></td></tr>
<tr class="separator:a3951ae1cd3580bcef46d3fc444dbdd73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cf1e3c73cb949835196b94075088d6d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8cf1e3c73cb949835196b94075088d6d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a8cf1e3c73cb949835196b94075088d6d">setImageSize</a> (int width, int height, bool resetCropRegion=true, bool resetRenderRegion=true)</td></tr>
<tr class="memdesc:a8cf1e3c73cb949835196b94075088d6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the frame buffer width and height. <br/></td></tr>
<tr class="separator:a8cf1e3c73cb949835196b94075088d6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afda167e5b5f312279dc2edff4c9ee85a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#afda167e5b5f312279dc2edff4c9ee85a">setImprovedDefaultSettings</a> ()</td></tr>
<tr class="separator:afda167e5b5f312279dc2edff4c9ee85a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc7dd856a5712f867e806b95bc81078a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acc7dd856a5712f867e806b95bc81078a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#acc7dd856a5712f867e806b95bc81078a">setKeepBucketsInCallback</a> (bool keep)</td></tr>
<tr class="memdesc:acc7dd856a5712f867e806b95bc81078a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method allows you to change the default behavior of keeping an image copy in a BucketReady callback parameter. <br/></td></tr>
<tr class="separator:acc7dd856a5712f867e806b95bc81078a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05252d74a01e9484fd44a7c5e93e691e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a05252d74a01e9484fd44a7c5e93e691e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a05252d74a01e9484fd44a7c5e93e691e">setKeepRTframesInCallback</a> (bool keep)</td></tr>
<tr class="memdesc:a05252d74a01e9484fd44a7c5e93e691e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method allows you to change the default behavior of keeping an image copy in a RTImageUpdated callback parameter. <br/></td></tr>
<tr class="separator:a05252d74a01e9484fd44a7c5e93e691e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dee3568d175aa5a2ad489301c279372"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3dee3568d175aa5a2ad489301c279372"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a3dee3568d175aa5a2ad489301c279372">setOnBucketFailed</a> (void(*callback)(<a class="el" href="class_v_ray_1_1_v_ray_renderer.html">VRayRenderer</a> &amp;, int x, int y, int width, int height, const char *host, void *), const void *userData=NULL)</td></tr>
<tr class="memdesc:a3dee3568d175aa5a2ad489301c279372"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set callback function for the event when an image bucket fails to render. This usually happens when a DR host drops. <br/></td></tr>
<tr class="separator:a3dee3568d175aa5a2ad489301c279372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a614db6e48f78f912a3b4e7076049809a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a614db6e48f78f912a3b4e7076049809a"></a>
template&lt;class T , void(T::*)(VRayRenderer &amp;, int x, int y, int width, int height, const char *host, void *) TMethod&gt; </td></tr>
<tr class="memitem:a614db6e48f78f912a3b4e7076049809a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a614db6e48f78f912a3b4e7076049809a">setOnBucketFailed</a> (T &amp;cls, const void *userData=NULL)</td></tr>
<tr class="memdesc:a614db6e48f78f912a3b4e7076049809a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set callback method for the event when an image bucket fails to render. This usually happens when a DR host drops. <br/></td></tr>
<tr class="separator:a614db6e48f78f912a3b4e7076049809a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74afc741eb1988fb888b590662bc39b6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a74afc741eb1988fb888b590662bc39b6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a74afc741eb1988fb888b590662bc39b6">setOnBucketInit</a> (void(*callback)(<a class="el" href="class_v_ray_1_1_v_ray_renderer.html">VRayRenderer</a> &amp;, int x, int y, int width, int height, const char *host, void *), const void *userData=NULL)</td></tr>
<tr class="memdesc:a74afc741eb1988fb888b590662bc39b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set callback function for the event when an image bucket has been assigned and started rendering. <br/></td></tr>
<tr class="separator:a74afc741eb1988fb888b590662bc39b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53252a913a8c4370abd008cbef5d0a8e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a53252a913a8c4370abd008cbef5d0a8e"></a>
template&lt;class T , void(T::*)(VRayRenderer &amp;, int x, int y, int width, int height, const char *host, void *) TMethod&gt; </td></tr>
<tr class="memitem:a53252a913a8c4370abd008cbef5d0a8e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a53252a913a8c4370abd008cbef5d0a8e">setOnBucketInit</a> (T &amp;cls, const void *userData=NULL)</td></tr>
<tr class="memdesc:a53252a913a8c4370abd008cbef5d0a8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set callback method for the event when an image bucket has been assigned and started rendering. <br/></td></tr>
<tr class="separator:a53252a913a8c4370abd008cbef5d0a8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2c0733f97b3fe7df4b19d064f3a19e5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae2c0733f97b3fe7df4b19d064f3a19e5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#ae2c0733f97b3fe7df4b19d064f3a19e5">setOnBucketReady</a> (void(*callback)(<a class="el" href="class_v_ray_1_1_v_ray_renderer.html">VRayRenderer</a> &amp;, int x, int y, const char *host, <a class="el" href="struct_v_ray_1_1_v_ray_image.html">VRayImage</a> *img, void *), const void *userData=NULL)</td></tr>
<tr class="memdesc:ae2c0733f97b3fe7df4b19d064f3a19e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set callback function for the event when an image bucket is completed. <br/></td></tr>
<tr class="separator:ae2c0733f97b3fe7df4b19d064f3a19e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fe20c7576af753178c9d140cb0163ed"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4fe20c7576af753178c9d140cb0163ed"></a>
template&lt;class T , void(T::*)(VRayRenderer &amp;, int x, int y, const char *host, VRayImage *img, void *) TMethod&gt; </td></tr>
<tr class="memitem:a4fe20c7576af753178c9d140cb0163ed"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a4fe20c7576af753178c9d140cb0163ed">setOnBucketReady</a> (T &amp;cls, const void *userData=NULL)</td></tr>
<tr class="memdesc:a4fe20c7576af753178c9d140cb0163ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set callback method for the event when an image bucket is completed. <br/></td></tr>
<tr class="separator:a4fe20c7576af753178c9d140cb0163ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa879c64276b394036b1f4ea122abf636"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa879c64276b394036b1f4ea122abf636"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#aa879c64276b394036b1f4ea122abf636">setOnDumpMessage</a> (void(*callback)(<a class="el" href="class_v_ray_1_1_v_ray_renderer.html">VRayRenderer</a> &amp;, const char *msg, int level, void *), const void *userData=NULL)</td></tr>
<tr class="memdesc:aa879c64276b394036b1f4ea122abf636"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set callback function for the event when V-Ray logs a text message. See enum MessageLevel. <br/></td></tr>
<tr class="separator:aa879c64276b394036b1f4ea122abf636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abce1d42d0a2b3ca9842a6ec15d1468fe"><td class="memTemplParams" colspan="2"><a class="anchor" id="abce1d42d0a2b3ca9842a6ec15d1468fe"></a>
template&lt;class T , void(T::*)(VRayRenderer &amp;, const char *msg, int level, void *) TMethod&gt; </td></tr>
<tr class="memitem:abce1d42d0a2b3ca9842a6ec15d1468fe"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#abce1d42d0a2b3ca9842a6ec15d1468fe">setOnDumpMessage</a> (T &amp;cls, const void *userData=NULL)</td></tr>
<tr class="memdesc:abce1d42d0a2b3ca9842a6ec15d1468fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set callback method for the event when V-Ray logs a text message. See enum MessageLevel. <br/></td></tr>
<tr class="separator:abce1d42d0a2b3ca9842a6ec15d1468fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e24368c649f352ce59199698ad3bc8e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9e24368c649f352ce59199698ad3bc8e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a9e24368c649f352ce59199698ad3bc8e">setOnImageReady</a> (void(*callback)(<a class="el" href="class_v_ray_1_1_v_ray_renderer.html">VRayRenderer</a> &amp;, void *), const void *userData=NULL)</td></tr>
<tr class="memdesc:a9e24368c649f352ce59199698ad3bc8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set callback function for the event when rendering has finished, successfully or not. <br/></td></tr>
<tr class="separator:a9e24368c649f352ce59199698ad3bc8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bfc9fc6d4f7a378cb845062b47ef20f"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4bfc9fc6d4f7a378cb845062b47ef20f"></a>
template&lt;class T , void(T::*)(VRayRenderer &amp;, void *) TMethod&gt; </td></tr>
<tr class="memitem:a4bfc9fc6d4f7a378cb845062b47ef20f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a4bfc9fc6d4f7a378cb845062b47ef20f">setOnImageReady</a> (T &amp;cls, const void *userData=NULL)</td></tr>
<tr class="memdesc:a4bfc9fc6d4f7a378cb845062b47ef20f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set callback method for the event when rendering has finished, successfully or not. <br/></td></tr>
<tr class="separator:a4bfc9fc6d4f7a378cb845062b47ef20f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45b789f331b951ec72505fc93af58c5c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a45b789f331b951ec72505fc93af58c5c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a45b789f331b951ec72505fc93af58c5c">setOnPostEffectsUpdated</a> (void(*callback)(<a class="el" href="class_v_ray_1_1_v_ray_renderer.html">VRayRenderer</a> &amp;, void *), const void *userData=NULL)</td></tr>
<tr class="memdesc:a45b789f331b951ec72505fc93af58c5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set callback function for the event when a new post-processed (denoised, lens effects) image is available. <br/></td></tr>
<tr class="separator:a45b789f331b951ec72505fc93af58c5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b0fb316c77ab5576e3cb18d588eb207"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4b0fb316c77ab5576e3cb18d588eb207"></a>
template&lt;class T , void(T::*)(VRayRenderer &amp;, void *) TMethod&gt; </td></tr>
<tr class="memitem:a4b0fb316c77ab5576e3cb18d588eb207"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a4b0fb316c77ab5576e3cb18d588eb207">setOnPostEffectsUpdated</a> (T &amp;cls, const void *userData=NULL)</td></tr>
<tr class="memdesc:a4b0fb316c77ab5576e3cb18d588eb207"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set callback function for the event when a new post-processed (denoised, lens effects) image is available. <br/></td></tr>
<tr class="separator:a4b0fb316c77ab5576e3cb18d588eb207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeec4f0cab6e5dd70d1e72156f6b8c2ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#aeec4f0cab6e5dd70d1e72156f6b8c2ea">setOnProgress</a> (void(*callback)(<a class="el" href="class_v_ray_1_1_v_ray_renderer.html">VRayRenderer</a> &amp;, const char *msg, int elementNumber, int elementsCount, void *), const void *userData=NULL)</td></tr>
<tr class="separator:aeec4f0cab6e5dd70d1e72156f6b8c2ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa98452fafe2f09404e4c796dcb5d718f"><td class="memTemplParams" colspan="2">template&lt;class T , void(T::*)(VRayRenderer &amp;, const char *msg, int elementNumber, int elementsCount, void *) TMethod&gt; </td></tr>
<tr class="memitem:aa98452fafe2f09404e4c796dcb5d718f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#aa98452fafe2f09404e4c796dcb5d718f">setOnProgress</a> (T &amp;cls, const void *userData=NULL)</td></tr>
<tr class="separator:aa98452fafe2f09404e4c796dcb5d718f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7688472224d7685956d44c0c0bc554b9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7688472224d7685956d44c0c0bc554b9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a7688472224d7685956d44c0c0bc554b9">setOnRendererClose</a> (void(*callback)(<a class="el" href="class_v_ray_1_1_v_ray_renderer.html">VRayRenderer</a> &amp;, void *), const void *userData=NULL)</td></tr>
<tr class="memdesc:a7688472224d7685956d44c0c0bc554b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set callback function for the event when the <a class="el" href="class_v_ray_1_1_v_ray_renderer.html" title="This class wraps the underlying V-Ray render engine and its scene contents. ">VRayRenderer</a> object is destroyed. <br/></td></tr>
<tr class="separator:a7688472224d7685956d44c0c0bc554b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2a25e1e206491fced3c122e92143bc4"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac2a25e1e206491fced3c122e92143bc4"></a>
template&lt;class T , void(T::*)(VRayRenderer &amp;, void *) TMethod&gt; </td></tr>
<tr class="memitem:ac2a25e1e206491fced3c122e92143bc4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#ac2a25e1e206491fced3c122e92143bc4">setOnRendererClose</a> (T &amp;cls, const void *userData=NULL)</td></tr>
<tr class="memdesc:ac2a25e1e206491fced3c122e92143bc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set callback method for the event when the <a class="el" href="class_v_ray_1_1_v_ray_renderer.html" title="This class wraps the underlying V-Ray render engine and its scene contents. ">VRayRenderer</a> object is destroyed. <br/></td></tr>
<tr class="separator:ac2a25e1e206491fced3c122e92143bc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2fdc9ae66347756c322bf7960e7ab88"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af2fdc9ae66347756c322bf7960e7ab88"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#af2fdc9ae66347756c322bf7960e7ab88">setOnRenderLast</a> (void(*callback)(<a class="el" href="class_v_ray_1_1_v_ray_renderer.html">VRayRenderer</a> &amp;, bool isRendering, void *), const void *userData=NULL)</td></tr>
<tr class="memdesc:af2fdc9ae66347756c322bf7960e7ab88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set callback function for the event when the "render last" <a class="el" href="class_v_ray_1_1_v_ray_renderer_1_1_v_f_b.html" title="This class groups all VFB related methods. ">VFB</a> button is pressed. <br/></td></tr>
<tr class="separator:af2fdc9ae66347756c322bf7960e7ab88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a269984cfe7e05cfac4be6110ca58be78"><td class="memTemplParams" colspan="2"><a class="anchor" id="a269984cfe7e05cfac4be6110ca58be78"></a>
template&lt;class T , void(T::*)(VRayRenderer &amp;, bool isRendering, void *) TMethod&gt; </td></tr>
<tr class="memitem:a269984cfe7e05cfac4be6110ca58be78"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a269984cfe7e05cfac4be6110ca58be78">setOnRenderLast</a> (T &amp;cls, const void *userData=NULL)</td></tr>
<tr class="memdesc:a269984cfe7e05cfac4be6110ca58be78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set callback method for the event when the "render last" <a class="el" href="class_v_ray_1_1_v_ray_renderer_1_1_v_f_b.html" title="This class groups all VFB related methods. ">VFB</a> button is pressed. <br/></td></tr>
<tr class="separator:a269984cfe7e05cfac4be6110ca58be78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31d0596e80324e290933825ec378005b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a31d0596e80324e290933825ec378005b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a31d0596e80324e290933825ec378005b">setOnRenderStart</a> (void(*callback)(<a class="el" href="class_v_ray_1_1_v_ray_renderer.html">VRayRenderer</a> &amp;, void *), const void *userData=NULL)</td></tr>
<tr class="memdesc:a31d0596e80324e290933825ec378005b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set callback function for the event when rendering has started after the preparation stage. <br/></td></tr>
<tr class="separator:a31d0596e80324e290933825ec378005b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8858f50cdeba700afd2f9f3841e1690"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa8858f50cdeba700afd2f9f3841e1690"></a>
template&lt;class T , void(T::*)(VRayRenderer &amp;, void *) TMethod&gt; </td></tr>
<tr class="memitem:aa8858f50cdeba700afd2f9f3841e1690"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#aa8858f50cdeba700afd2f9f3841e1690">setOnRenderStart</a> (T &amp;cls, const void *userData=NULL)</td></tr>
<tr class="memdesc:aa8858f50cdeba700afd2f9f3841e1690"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set callback method for the event when rendering has started after the preparation stage. <br/></td></tr>
<tr class="separator:aa8858f50cdeba700afd2f9f3841e1690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a510a43fc30ce21520bdc3754d3665fc2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a510a43fc30ce21520bdc3754d3665fc2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a510a43fc30ce21520bdc3754d3665fc2">setOnRenderViewChanged</a> (void(*callback)(<a class="el" href="class_v_ray_1_1_v_ray_renderer.html">VRayRenderer</a> &amp;, const char *propName, void *), const void *userData=NULL)</td></tr>
<tr class="memdesc:a510a43fc30ce21520bdc3754d3665fc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set callback function for the event when the RenderView (camera) plugin has changed in RT mode. <br/></td></tr>
<tr class="separator:a510a43fc30ce21520bdc3754d3665fc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab65f9154aefc3086279ad23268aa3310"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab65f9154aefc3086279ad23268aa3310"></a>
template&lt;class T , void(T::*)(VRayRenderer &amp;, const char *propName, void *) TMethod&gt; </td></tr>
<tr class="memitem:ab65f9154aefc3086279ad23268aa3310"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#ab65f9154aefc3086279ad23268aa3310">setOnRenderViewChanged</a> (T &amp;cls, const void *userData=NULL)</td></tr>
<tr class="memdesc:ab65f9154aefc3086279ad23268aa3310"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set callback method for the event when the RenderView (camera) plugin has changed in RT mode. <br/></td></tr>
<tr class="separator:ab65f9154aefc3086279ad23268aa3310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a241abf90ca00ad5cefd5313ede5554aa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a241abf90ca00ad5cefd5313ede5554aa"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a241abf90ca00ad5cefd5313ede5554aa">setOnRTImageUpdated</a> (void(*callback)(<a class="el" href="class_v_ray_1_1_v_ray_renderer.html">VRayRenderer</a> &amp;, <a class="el" href="struct_v_ray_1_1_v_ray_image.html">VRayImage</a> *img, void *), const void *userData=NULL)</td></tr>
<tr class="memdesc:a241abf90ca00ad5cefd5313ede5554aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set callback function for the event when an updated image is available in progressive rendering mode. <br/></td></tr>
<tr class="separator:a241abf90ca00ad5cefd5313ede5554aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1db25eb253855daabd58b54bc44b745"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad1db25eb253855daabd58b54bc44b745"></a>
template&lt;class T , void(T::*)(VRayRenderer &amp;, VRayImage *img, void *) TMethod&gt; </td></tr>
<tr class="memitem:ad1db25eb253855daabd58b54bc44b745"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#ad1db25eb253855daabd58b54bc44b745">setOnRTImageUpdated</a> (T &amp;cls, const void *userData=NULL)</td></tr>
<tr class="memdesc:ad1db25eb253855daabd58b54bc44b745"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set callback method for the event when an updated image is available in progressive rendering mode. <br/></td></tr>
<tr class="separator:ad1db25eb253855daabd58b54bc44b745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdbca73785a16d914441002dbad4271a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afdbca73785a16d914441002dbad4271a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#afdbca73785a16d914441002dbad4271a">setOnSequenceDone</a> (void(*callback)(<a class="el" href="class_v_ray_1_1_v_ray_renderer.html">VRayRenderer</a> &amp;, void *), const void *userData=NULL)</td></tr>
<tr class="memdesc:afdbca73785a16d914441002dbad4271a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set callback function for the event when an animation sequence has finished rendering. <br/></td></tr>
<tr class="separator:afdbca73785a16d914441002dbad4271a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21f740648d0333a5ab313d907a735f1c"><td class="memTemplParams" colspan="2"><a class="anchor" id="a21f740648d0333a5ab313d907a735f1c"></a>
template&lt;class T , void(T::*)(VRayRenderer &amp;, void *) TMethod&gt; </td></tr>
<tr class="memitem:a21f740648d0333a5ab313d907a735f1c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a21f740648d0333a5ab313d907a735f1c">setOnSequenceDone</a> (T &amp;cls, const void *userData=NULL)</td></tr>
<tr class="memdesc:a21f740648d0333a5ab313d907a735f1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set callback method for the event when an animation sequence has finished rendering. <br/></td></tr>
<tr class="separator:a21f740648d0333a5ab313d907a735f1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a429f36f125c436ffbec27627ddff420b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a429f36f125c436ffbec27627ddff420b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a429f36f125c436ffbec27627ddff420b">setOnSequenceStart</a> (void(*callback)(<a class="el" href="class_v_ray_1_1_v_ray_renderer.html">VRayRenderer</a> &amp;, void *), const void *userData=NULL)</td></tr>
<tr class="memdesc:a429f36f125c436ffbec27627ddff420b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set callback function for the event when an animation sequence has started rendering after the initial preparation stage. <br/></td></tr>
<tr class="separator:a429f36f125c436ffbec27627ddff420b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0979534dbcc8a7d9d4ea778f6a6ffd6"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab0979534dbcc8a7d9d4ea778f6a6ffd6"></a>
template&lt;class T , void(T::*)(VRayRenderer &amp;, void *) TMethod&gt; </td></tr>
<tr class="memitem:ab0979534dbcc8a7d9d4ea778f6a6ffd6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#ab0979534dbcc8a7d9d4ea778f6a6ffd6">setOnSequenceStart</a> (T &amp;cls, const void *userData=NULL)</td></tr>
<tr class="memdesc:ab0979534dbcc8a7d9d4ea778f6a6ffd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set callback method for the event when an animation sequence has started rendering after the initial preparation stage. <br/></td></tr>
<tr class="separator:ab0979534dbcc8a7d9d4ea778f6a6ffd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc1f14bacc18390baa44cb861fdc118b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afc1f14bacc18390baa44cb861fdc118b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#afc1f14bacc18390baa44cb861fdc118b">setOnShowMessagesWindow</a> (void(*callback)(<a class="el" href="class_v_ray_1_1_v_ray_renderer.html">VRayRenderer</a> &amp;, void *), const void *userData=NULL)</td></tr>
<tr class="memdesc:afc1f14bacc18390baa44cb861fdc118b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set callback function for the event when the message window button in the <a class="el" href="class_v_ray_1_1_v_ray_renderer_1_1_v_f_b.html" title="This class groups all VFB related methods. ">VFB</a> is clicked. <br/></td></tr>
<tr class="separator:afc1f14bacc18390baa44cb861fdc118b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a154cacfc687759314a6bed8bf48832b9"><td class="memTemplParams" colspan="2"><a class="anchor" id="a154cacfc687759314a6bed8bf48832b9"></a>
template&lt;class T , void(T::*)(VRayRenderer &amp;, void *) TMethod&gt; </td></tr>
<tr class="memitem:a154cacfc687759314a6bed8bf48832b9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a154cacfc687759314a6bed8bf48832b9">setOnShowMessagesWindow</a> (T &amp;cls, const void *userData=NULL)</td></tr>
<tr class="memdesc:a154cacfc687759314a6bed8bf48832b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set callback function for the event when the message window button in the <a class="el" href="class_v_ray_1_1_v_ray_renderer_1_1_v_f_b.html" title="This class groups all VFB related methods. ">VFB</a> is clicked. <br/></td></tr>
<tr class="separator:a154cacfc687759314a6bed8bf48832b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af148cbd5aa73adc192467a6fa43f6d35"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af148cbd5aa73adc192467a6fa43f6d35"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#af148cbd5aa73adc192467a6fa43f6d35">setOnVFBClosed</a> (void(*callback)(<a class="el" href="class_v_ray_1_1_v_ray_renderer.html">VRayRenderer</a> &amp;, void *), const void *userData=NULL)</td></tr>
<tr class="memdesc:af148cbd5aa73adc192467a6fa43f6d35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set callback function for the event when the <a class="el" href="class_v_ray_1_1_v_ray_renderer_1_1_v_f_b.html" title="This class groups all VFB related methods. ">VFB</a> window is closed. <br/></td></tr>
<tr class="separator:af148cbd5aa73adc192467a6fa43f6d35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2519879a8f4bc9abb167f3b7cd955929"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2519879a8f4bc9abb167f3b7cd955929"></a>
template&lt;class T , void(T::*)(VRayRenderer &amp;, void *) TMethod&gt; </td></tr>
<tr class="memitem:a2519879a8f4bc9abb167f3b7cd955929"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a2519879a8f4bc9abb167f3b7cd955929">setOnVFBClosed</a> (T &amp;cls, const void *userData=NULL)</td></tr>
<tr class="memdesc:a2519879a8f4bc9abb167f3b7cd955929"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set callback method for the event when the <a class="el" href="class_v_ray_1_1_v_ray_renderer_1_1_v_f_b.html" title="This class groups all VFB related methods. ">VFB</a> window is closed. <br/></td></tr>
<tr class="separator:a2519879a8f4bc9abb167f3b7cd955929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38f47dfcb83df0b7b4dd4aaf003e97ec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a38f47dfcb83df0b7b4dd4aaf003e97ec"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a38f47dfcb83df0b7b4dd4aaf003e97ec">setOptions</a> (const <a class="el" href="struct_v_ray_1_1_renderer_options.html">RendererOptions</a> &amp;options)</td></tr>
<tr class="memdesc:a38f47dfcb83df0b7b4dd4aaf003e97ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass a new set of options. The renderer must be idle for this to work. <br/></td></tr>
<tr class="separator:a38f47dfcb83df0b7b4dd4aaf003e97ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab64b54a22897818a8b7b673c2dc889e3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#ab64b54a22897818a8b7b673c2dc889e3">setRenderMode</a> (RendererOptions::RenderMode mode)</td></tr>
<tr class="separator:ab64b54a22897818a8b7b673c2dc889e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4103841675886ee7fa640951cae16d7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#ad4103841675886ee7fa640951cae16d7">setRenderRegion</a> (int rgnLeft, int rgnTop, int rgnWidth, int rgnHeight)</td></tr>
<tr class="separator:ad4103841675886ee7fa640951cae16d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af956a80e38c89d1398fc832cdb07a687"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#af956a80e38c89d1398fc832cdb07a687">setResumableRendering</a> (bool enable, const <a class="el" href="struct_v_ray_1_1_resumable_rendering_options.html">ResumableRenderingOptions</a> *options)</td></tr>
<tr class="separator:af956a80e38c89d1398fc832cdb07a687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab117de464cb51da71ba2ca57d0abb076"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#ab117de464cb51da71ba2ca57d0abb076">setRTImageUpdateDifference</a> (float difference)</td></tr>
<tr class="separator:ab117de464cb51da71ba2ca57d0abb076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac095b9aec40fe4956250e5a087060fee"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#ac095b9aec40fe4956250e5a087060fee">setRTImageUpdateTimeout</a> (unsigned long timeout)</td></tr>
<tr class="separator:ac095b9aec40fe4956250e5a087060fee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b57775bee905444fc309b1e4b633a3b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9b57775bee905444fc309b1e4b633a3b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a9b57775bee905444fc309b1e4b633a3b">setWidth</a> (int width, bool resetCropRegion=true, bool resetRenderRegion=true)</td></tr>
<tr class="memdesc:a9b57775bee905444fc309b1e4b633a3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the frame buffer width. <br/></td></tr>
<tr class="separator:a9b57775bee905444fc309b1e4b633a3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad32be50f400edab3fc4640938042fa37"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#ad32be50f400edab3fc4640938042fa37">start</a> () const </td></tr>
<tr class="separator:ad32be50f400edab3fc4640938042fa37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b9fcc4fded0eb20c53d38a705ef3c70"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2b9fcc4fded0eb20c53d38a705ef3c70"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a2b9fcc4fded0eb20c53d38a705ef3c70">startSync</a> () const </td></tr>
<tr class="memdesc:a2b9fcc4fded0eb20c53d38a705ef3c70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins the rendering process in a separate thread. Blocks until the preparation stage is complete and rendering has actually started. <br/></td></tr>
<tr class="separator:a2b9fcc4fded0eb20c53d38a705ef3c70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa48f41c4c484e5c8458149fc00870a00"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa48f41c4c484e5c8458149fc00870a00"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#aa48f41c4c484e5c8458149fc00870a00">stop</a> () const </td></tr>
<tr class="memdesc:aa48f41c4c484e5c8458149fc00870a00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags the image rendering thread to stop and waits for it to join. <br/></td></tr>
<tr class="separator:aa48f41c4c484e5c8458149fc00870a00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8b75bb6affb2cd272b6156774388456"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#af8b75bb6affb2cd272b6156774388456">useAnimatedValues</a> (bool on)</td></tr>
<tr class="separator:af8b75bb6affb2cd272b6156774388456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a131905876d9222c10b08176a56ed7944"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a131905876d9222c10b08176a56ed7944">waitForImageReady</a> () const </td></tr>
<tr class="separator:a131905876d9222c10b08176a56ed7944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3b0e4b59bf82716b222bb15f68250ab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#ad3b0e4b59bf82716b222bb15f68250ab">waitForImageReady</a> (const int timeout) const </td></tr>
<tr class="separator:ad3b0e4b59bf82716b222bb15f68250ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d75a7fef2e7be88ff0fef4f6d5d46ab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a4d75a7fef2e7be88ff0fef4f6d5d46ab">waitForSequenceDone</a> () const </td></tr>
<tr class="separator:a4d75a7fef2e7be88ff0fef4f6d5d46ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affed33777dbcd62141ccbbf589b619a0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#affed33777dbcd62141ccbbf589b619a0">waitForSequenceDone</a> (const int timeout) const </td></tr>
<tr class="separator:affed33777dbcd62141ccbbf589b619a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:af7bccb0c6c20a5e1cfc1b2f2d5c652e3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af7bccb0c6c20a5e1cfc1b2f2d5c652e3"></a>
class <a class="el" href="class_v_ray_1_1_v_ray_renderer_1_1_v_f_b.html">VRay::VRayRenderer::VFB</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html#af7bccb0c6c20a5e1cfc1b2f2d5c652e3">vfb</a></td></tr>
<tr class="memdesc:af7bccb0c6c20a5e1cfc1b2f2d5c652e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">"property" or "namespace" vfb within <a class="el" href="class_v_ray_1_1_v_ray_renderer.html" title="This class wraps the underlying V-Ray render engine and its scene contents. ">VRayRenderer</a> <br/></td></tr>
<tr class="separator:af7bccb0c6c20a5e1cfc1b2f2d5c652e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a38911b6b618c7c2586b2ba19c60fef59"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a38911b6b618c7c2586b2ba19c60fef59"></a>
VRayRendererNative *&#160;</td><td class="memItemRight" valign="bottom"><b>getNativeRenderer</b> () const </td></tr>
<tr class="separator:a38911b6b618c7c2586b2ba19c60fef59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72f4d4d2fb0a6c03fb3f559df1187467"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a72f4d4d2fb0a6c03fb3f559df1187467"></a>
<a class="el" href="class_v_ray_1_1_plugin.html">Plugin</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getPlugin_internal</b> (InstanceId pluginID) const </td></tr>
<tr class="separator:a72f4d4d2fb0a6c03fb3f559df1187467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16f9c0399bd83a14131d4616f16b54ac"><td class="memTemplParams" colspan="2"><a class="anchor" id="a16f9c0399bd83a14131d4616f16b54ac"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a16f9c0399bd83a14131d4616f16b54ac"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getPlugin_internal</b> (InstanceId pluginID) const </td></tr>
<tr class="separator:a16f9c0399bd83a14131d4616f16b54ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a408fddc4631a62dd15e9ead22ab53f91"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a408fddc4631a62dd15e9ead22ab53f91"></a>
InstanceId&#160;</td><td class="memItemRight" valign="bottom"><b>getPluginId_internal</b> (const char *pluginName) const </td></tr>
<tr class="separator:a408fddc4631a62dd15e9ead22ab53f91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a990c257768b42c22651e081184815924"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a990c257768b42c22651e081184815924"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><b>getPluginName_internal</b> (InstanceId pluginID) const </td></tr>
<tr class="separator:a990c257768b42c22651e081184815924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaeac96000b67b2f7f2bc4336dac5b78"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adaeac96000b67b2f7f2bc4336dac5b78"></a>
<a class="el" href="struct_v_ray_1_1_a_color.html">AColor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getPluginPropertyAColor</b> (const char *pluginName, const char *propertyName, bool &amp;ok) const </td></tr>
<tr class="separator:adaeac96000b67b2f7f2bc4336dac5b78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad75bfc319eb88ad619eba1c58da3ff26"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad75bfc319eb88ad619eba1c58da3ff26"></a>
<a class="el" href="struct_v_ray_1_1_a_color.html">AColor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getPluginPropertyAColor</b> (InstanceId pluginID, const char *propertyName, bool &amp;ok) const </td></tr>
<tr class="separator:ad75bfc319eb88ad619eba1c58da3ff26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf05562a2727f4fa0df027b8751afc7b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acf05562a2727f4fa0df027b8751afc7b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>getPluginPropertyBool</b> (const char *pluginName, const char *propertyName, bool &amp;ok) const </td></tr>
<tr class="separator:acf05562a2727f4fa0df027b8751afc7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc2920028a59554281b9604bdd6ebb38"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adc2920028a59554281b9604bdd6ebb38"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>getPluginPropertyBool</b> (InstanceId pluginID, const char *propertyName, bool &amp;ok) const </td></tr>
<tr class="separator:adc2920028a59554281b9604bdd6ebb38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d566bceef69515ed0d79ac63cb2e673"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5d566bceef69515ed0d79ac63cb2e673"></a>
<a class="el" href="struct_v_ray_1_1_color.html">Color</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getPluginPropertyColor</b> (const char *pluginName, const char *propertyName, bool &amp;ok) const </td></tr>
<tr class="separator:a5d566bceef69515ed0d79ac63cb2e673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e1d7740dea70948c3b3aebe87456e2b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8e1d7740dea70948c3b3aebe87456e2b"></a>
<a class="el" href="struct_v_ray_1_1_color.html">Color</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getPluginPropertyColor</b> (InstanceId pluginID, const char *propertyName, bool &amp;ok) const </td></tr>
<tr class="separator:a8e1d7740dea70948c3b3aebe87456e2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa71bb5d491fcea2466745a8614a50178"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa71bb5d491fcea2466745a8614a50178"></a>
const void *&#160;</td><td class="memItemRight" valign="bottom"><b>getPluginPropertyDefinition</b> (const char *pluginName, const char *propertyName) const </td></tr>
<tr class="separator:aa71bb5d491fcea2466745a8614a50178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a868d16080398c76cefc7b09526921433"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a868d16080398c76cefc7b09526921433"></a>
const void *&#160;</td><td class="memItemRight" valign="bottom"><b>getPluginPropertyDefinition</b> (InstanceId pluginID, const char *propertyName) const </td></tr>
<tr class="separator:a868d16080398c76cefc7b09526921433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2dadfeeb3f9e88189257b60ece81d44"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad2dadfeeb3f9e88189257b60ece81d44"></a>
const void *&#160;</td><td class="memItemRight" valign="bottom"><b>getPluginPropertyDefinitionFromClass</b> (const char *pluginClassName, const char *propertyName) const </td></tr>
<tr class="separator:ad2dadfeeb3f9e88189257b60ece81d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26028ea881d0fa2e4aaeb8a688307e79"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a26028ea881d0fa2e4aaeb8a688307e79"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getPluginPropertyElementsCount</b> (InstanceId pluginID, const char *propertyName) const </td></tr>
<tr class="separator:a26028ea881d0fa2e4aaeb8a688307e79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92a1cb84bb4285e1af418c43daf7c2bc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a92a1cb84bb4285e1af418c43daf7c2bc"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>getPluginPropertyFloat</b> (const char *pluginName, const char *propertyName, bool &amp;ok) const </td></tr>
<tr class="separator:a92a1cb84bb4285e1af418c43daf7c2bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a977db5a58d4007e96c12e1e7768e307d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a977db5a58d4007e96c12e1e7768e307d"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>getPluginPropertyFloat</b> (InstanceId pluginID, const char *propertyName, bool &amp;ok) const </td></tr>
<tr class="separator:a977db5a58d4007e96c12e1e7768e307d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a1d462e6bfa82fee04acd028dba746c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9a1d462e6bfa82fee04acd028dba746c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getPluginPropertyInt</b> (const char *pluginName, const char *propertyName, bool &amp;ok) const </td></tr>
<tr class="separator:a9a1d462e6bfa82fee04acd028dba746c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6552bf170c0ad91adf08ee5d420c8b8e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6552bf170c0ad91adf08ee5d420c8b8e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getPluginPropertyInt</b> (InstanceId pluginID, const char *propertyName, bool &amp;ok) const </td></tr>
<tr class="separator:a6552bf170c0ad91adf08ee5d420c8b8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1de0622480bec336a819a33dcfc79fc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa1de0622480bec336a819a33dcfc79fc"></a>
<a class="el" href="struct_v_ray_1_1_matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getPluginPropertyMatrix</b> (const char *pluginName, const char *propertyName, bool &amp;ok) const </td></tr>
<tr class="separator:aa1de0622480bec336a819a33dcfc79fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa72237e38331783465da7cc0c3b5ce94"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa72237e38331783465da7cc0c3b5ce94"></a>
<a class="el" href="struct_v_ray_1_1_matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getPluginPropertyMatrix</b> (InstanceId pluginID, const char *propertyName, bool &amp;ok) const </td></tr>
<tr class="separator:aa72237e38331783465da7cc0c3b5ce94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a932e8744acb4851ecb499dcb21c5aaf4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a932e8744acb4851ecb499dcb21c5aaf4"></a>
std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getPluginPropertyNames</b> (const char *pluginClassName) const </td></tr>
<tr class="separator:a932e8744acb4851ecb499dcb21c5aaf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3adc6eaf2a2725f78349b1e5804aebe4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3adc6eaf2a2725f78349b1e5804aebe4"></a>
<a class="el" href="class_v_ray_1_1_plugin.html">Plugin</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getPluginPropertyPluginProperty</b> (InstanceId pluginID, const char *propertyName, const char **outPropertyName, bool &amp;ok) const </td></tr>
<tr class="separator:a3adc6eaf2a2725f78349b1e5804aebe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4d148a1156a69b8b42e83851fe680f7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae4d148a1156a69b8b42e83851fe680f7"></a>
Type&#160;</td><td class="memItemRight" valign="bottom"><b>getPluginPropertyRuntimeType</b> (const char *pluginName, const char *propertyName) const </td></tr>
<tr class="separator:ae4d148a1156a69b8b42e83851fe680f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6aa5b730e051dd49774bf551997afbf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac6aa5b730e051dd49774bf551997afbf"></a>
Type&#160;</td><td class="memItemRight" valign="bottom"><b>getPluginPropertyRuntimeType</b> (InstanceId pluginID, const char *propertyName) const </td></tr>
<tr class="separator:ac6aa5b730e051dd49774bf551997afbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76f5f7fcbf3348750e0addd2f5e9b5fc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a76f5f7fcbf3348750e0addd2f5e9b5fc"></a>
<a class="el" href="struct_v_ray_1_1_transform.html">Transform</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getPluginPropertyTransform</b> (const char *pluginName, const char *propertyName, bool &amp;ok) const </td></tr>
<tr class="separator:a76f5f7fcbf3348750e0addd2f5e9b5fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ee2b06cc6e48974169a1d087c2420c3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9ee2b06cc6e48974169a1d087c2420c3"></a>
<a class="el" href="struct_v_ray_1_1_transform.html">Transform</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getPluginPropertyTransform</b> (InstanceId pluginID, const char *propertyName, bool &amp;ok) const </td></tr>
<tr class="separator:a9ee2b06cc6e48974169a1d087c2420c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab119638c462918addd63bbb2c0a27fa"><td class="memTemplParams" colspan="2"><a class="anchor" id="aab119638c462918addd63bbb2c0a27fa"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aab119638c462918addd63bbb2c0a27fa"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getPluginPropertyTyped</b> (InstanceId pluginID, const char *propertyName, bool &amp;ok) const </td></tr>
<tr class="separator:aab119638c462918addd63bbb2c0a27fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05f15d0de0e44684e357e58e547a55c7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a05f15d0de0e44684e357e58e547a55c7"></a>
<a class="el" href="class_v_ray_1_1_value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getPluginPropertyValue</b> (InstanceId pluginID, const char *propertyName, bool &amp;ok) const </td></tr>
<tr class="separator:a05f15d0de0e44684e357e58e547a55c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f2bce0631c25bd493190cab16fc05b0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3f2bce0631c25bd493190cab16fc05b0"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>getPluginPropertyValueAsString</b> (const char *pluginName, const char *propertyName) const </td></tr>
<tr class="separator:a3f2bce0631c25bd493190cab16fc05b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96dcfe243dcfb347874f5dc60f977ab3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a96dcfe243dcfb347874f5dc60f977ab3"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>getPluginPropertyValueAsString</b> (InstanceId pluginID, const char *propertyName, bool &amp;ok) const </td></tr>
<tr class="separator:a96dcfe243dcfb347874f5dc60f977ab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab009c0f83e18948a0c6826f12b0c58a8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab009c0f83e18948a0c6826f12b0c58a8"></a>
<a class="el" href="struct_v_ray_1_1_vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getPluginPropertyVector</b> (const char *pluginName, const char *propertyName, bool &amp;ok) const </td></tr>
<tr class="separator:ab009c0f83e18948a0c6826f12b0c58a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4df00d3c54711d290f107e3095a7b55d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4df00d3c54711d290f107e3095a7b55d"></a>
<a class="el" href="struct_v_ray_1_1_vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getPluginPropertyVector</b> (InstanceId pluginID, const char *propertyName, bool &amp;ok) const </td></tr>
<tr class="separator:a4df00d3c54711d290f107e3095a7b55d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a215a52ce6e3263fd376502f7c1ea03b1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a215a52ce6e3263fd376502f7c1ea03b1"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><b>getPluginType</b> (const char *name) const </td></tr>
<tr class="separator:a215a52ce6e3263fd376502f7c1ea03b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2186f15184ca9228c3a9ce7cb6ff11f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab2186f15184ca9228c3a9ce7cb6ff11f"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><b>getPluginType</b> (InstanceId pluginID) const </td></tr>
<tr class="separator:ab2186f15184ca9228c3a9ce7cb6ff11f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae789f4573ebfb7faae4caada47eabb04"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae789f4573ebfb7faae4caada47eabb04"></a>
<a class="el" href="struct_v_ray_1_1_v_ray_image.html">VRayImage</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getRenderElementAsImage</b> (InstanceId pluginID, const <a class="el" href="struct_v_ray_1_1_image_region.html">ImageRegion</a> *rgn) const </td></tr>
<tr class="separator:ae789f4573ebfb7faae4caada47eabb04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58c4bf75fff3f585c0b2c08125717459"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a58c4bf75fff3f585c0b2c08125717459"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>getRenderElementData</b> (InstanceId pluginID, InstanceId alphaPluginID, <a class="el" href="class_v_ray_1_1_render_element.html#a0dd63831006e0df96059817000b35554">RenderElement::PixelFormat</a> format, bool rgbOrder, const <a class="el" href="struct_v_ray_1_1_image_region.html">ImageRegion</a> *rgn, void **buf) const </td></tr>
<tr class="separator:a58c4bf75fff3f585c0b2c08125717459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c1c5610fefb8d874d5aa39fe8b267fc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c1c5610fefb8d874d5aa39fe8b267fc"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>getRenderElementInfo</b> (InstanceId pluginID, <a class="el" href="struct_v_ray_1_1_render_element_1_1_info.html">RenderElement::Info</a> &amp;chInfo) const </td></tr>
<tr class="separator:a8c1c5610fefb8d874d5aa39fe8b267fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a875475580247e6c3be439af0718c7beb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a875475580247e6c3be439af0718c7beb"></a>
<a class="el" href="class_v_ray_1_1_plugin.html">Plugin</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getRenderElementPlugin</b> (int type) const </td></tr>
<tr class="separator:a875475580247e6c3be439af0718c7beb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ec49ef8f666e9a43b38ba24139a17d8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8ec49ef8f666e9a43b38ba24139a17d8"></a>
std::vector&lt; <a class="el" href="class_v_ray_1_1_plugin.html">Plugin</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getRenderElementPluginsList</b> (int type) const </td></tr>
<tr class="separator:a8ec49ef8f666e9a43b38ba24139a17d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42484bf10b4254944fa105491fa3f594"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a42484bf10b4254944fa105491fa3f594"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isPropertyAnimated</b> (InstanceId pluginID, const char *propertyName) const </td></tr>
<tr class="separator:a42484bf10b4254944fa105491fa3f594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74a93a4174d3c68f892c102fb6c9f663"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a74a93a4174d3c68f892c102fb6c9f663"></a>
<a class="el" href="class_v_ray_1_1_plugin.html">Plugin</a>&#160;</td><td class="memItemRight" valign="bottom"><b>newRenderElementPlugin</b> (int type, const char *instanceName, const char *displayName)</td></tr>
<tr class="separator:a74a93a4174d3c68f892c102fb6c9f663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b90e1cc25f41837918a0b7a762a1bc3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1b90e1cc25f41837918a0b7a762a1bc3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>pluginExists_internal</b> (InstanceId pluginID) const </td></tr>
<tr class="separator:a1b90e1cc25f41837918a0b7a762a1bc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a3ed632a97c75b9f0eb7d4a46f60ab9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7a3ed632a97c75b9f0eb7d4a46f60ab9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>setPluginName</b> (InstanceId pluginID, const char *name) const </td></tr>
<tr class="separator:a7a3ed632a97c75b9f0eb7d4a46f60ab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f237299c746cab2536fe2c5ca96ef92"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0f237299c746cab2536fe2c5ca96ef92"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>setPluginPropertyValue</b> (InstanceId pluginID, const char *propertyName, const void *pval) const </td></tr>
<tr class="separator:a0f237299c746cab2536fe2c5ca96ef92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4106530015cb6a2e4de9108b71fa74e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae4106530015cb6a2e4de9108b71fa74e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>setPluginPropertyValueAsString</b> (InstanceId pluginID, const char *propertyName, const char *value) const </td></tr>
<tr class="separator:ae4106530015cb6a2e4de9108b71fa74e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afba8ee5cc0f3878876644af4e4c6f64f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afba8ee5cc0f3878876644af4e4c6f64f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>setPluginPropertyValueAsStringAtTime</b> (InstanceId pluginID, const char *propertyName, const char *value, double time) const </td></tr>
<tr class="separator:afba8ee5cc0f3878876644af4e4c6f64f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63fd5e542381274810ca1e66ffc58535"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a63fd5e542381274810ca1e66ffc58535"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>setPluginPropertyValueAtTime</b> (InstanceId pluginID, const char *propertyName, const void *pval, double time) const </td></tr>
<tr class="separator:a63fd5e542381274810ca1e66ffc58535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8348297f8be74a4361678100a745d0f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad8348297f8be74a4361678100a745d0f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>setPluginPropertyValueRaw</b> (InstanceId pluginID, const char *propertyName, const void *pval, size_t count) const </td></tr>
<tr class="separator:ad8348297f8be74a4361678100a745d0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25f727277f44a079131339ab190cdfce"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a25f727277f44a079131339ab190cdfce"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>setPluginPropertyValueRawAtTime</b> (InstanceId pluginID, const char *propertyName, const void *pval, size_t count, double time) const </td></tr>
<tr class="separator:a25f727277f44a079131339ab190cdfce"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:ae1ad1890fe467e5db42d0190f064482f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae1ad1890fe467e5db42d0190f064482f"></a>
static std::vector&lt; InstanceId &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getPluginIdsOfType</b> (VRayRendererNative *rendererNative, const char *pluginType=NULL)</td></tr>
<tr class="separator:ae1ad1890fe467e5db42d0190f064482f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa912071e10c2f64d31fab85025a50e97"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa912071e10c2f64d31fab85025a50e97"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aa912071e10c2f64d31fab85025a50e97"><td class="memTemplItemLeft" align="right" valign="top">static std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getPluginsOfType</b> (<a class="el" href="class_v_ray_1_1_v_ray_renderer.html">VRayRenderer</a> &amp;renderer, const char *pluginType)</td></tr>
<tr class="separator:aa912071e10c2f64d31fab85025a50e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5f48ea05ac57995bbdb1fb6723fd32d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac5f48ea05ac57995bbdb1fb6723fd32d"></a>
static std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getStringVector</b> (void *pvector)</td></tr>
<tr class="separator:ac5f48ea05ac57995bbdb1fb6723fd32d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a10f31732ff5a64e227819b6fa0ed430f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a10f31732ff5a64e227819b6fa0ed430f"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>LocalBmp</b></td></tr>
<tr class="separator:a10f31732ff5a64e227819b6fa0ed430f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46277679e517e5f5114d93ffcb1f7d2c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a46277679e517e5f5114d93ffcb1f7d2c"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>LocalJpeg</b></td></tr>
<tr class="separator:a46277679e517e5f5114d93ffcb1f7d2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ec875037390e537434457890aa60685"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5ec875037390e537434457890aa60685"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>LocalPng</b></td></tr>
<tr class="separator:a5ec875037390e537434457890aa60685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a6c1cc25d50ed6f67a2dc0fc546c5a3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6a6c1cc25d50ed6f67a2dc0fc546c5a3"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>Plugin</b></td></tr>
<tr class="separator:a6a6c1cc25d50ed6f67a2dc0fc546c5a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac09afc3256ca375a7eee37524252991c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac09afc3256ca375a7eee37524252991c"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>PluginMeta</b></td></tr>
<tr class="separator:ac09afc3256ca375a7eee37524252991c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6371359367bd81a4db0745bf9b5fc52"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae6371359367bd81a4db0745bf9b5fc52"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>PropertyMeta</b></td></tr>
<tr class="separator:ae6371359367bd81a4db0745bf9b5fc52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c49c749704bf46129f950093ea237ef"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7c49c749704bf46129f950093ea237ef"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>PropertyRuntimeMeta</b></td></tr>
<tr class="separator:a7c49c749704bf46129f950093ea237ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4c9bef662740ca1355e442a26248621"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af4c9bef662740ca1355e442a26248621"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>RenderElement</b></td></tr>
<tr class="separator:af4c9bef662740ca1355e442a26248621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cd61c209c5cc17fc66f0525de5bf303"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2cd61c209c5cc17fc66f0525de5bf303"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>RenderElements</b></td></tr>
<tr class="separator:a2cd61c209c5cc17fc66f0525de5bf303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9292b69ce4bf39af66403008406ba002"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9292b69ce4bf39af66403008406ba002"></a>
struct&#160;</td><td class="memItemRight" valign="bottom"><b>VRayImage</b></td></tr>
<tr class="separator:a9292b69ce4bf39af66403008406ba002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61e03254413cafccb8f1148c4b720cc3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a61e03254413cafccb8f1148c4b720cc3"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>VRayServer</b></td></tr>
<tr class="separator:a61e03254413cafccb8f1148c4b720cc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class wraps the underlying V-Ray render engine and its scene contents. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a478cb6103557b3d78baf93684ee490ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AddHostsResult VRay::VRayRenderer::addHosts </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>hosts</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds hosts to the list for distributed rendering. If rendering is already in process, they are connected directly. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hosts</td><td>IP:port (or hostname:port) pairs as string delimited by ',' or ';' </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">See</td><td>the AddHostsResult enum comments </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2119e624f5028a49957be113ad0f434b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AddHostsResult VRay::VRayRenderer::addHosts </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>hosts</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="aa5b156d68bda49e3d5cf90b884b998e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VRay::VRayRenderer::append </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fileName</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Appends the specified scene file data to the currently loaded scene without wiping it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fileName</td><td>The file path to the .vrscene file which will be appended. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>- no error; check <a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a5df8e0d290de1d52f6e19751a48f92c2" title="Returns the parser error that occurred when a scene was last loaded or appended. ">getLastParserError()</a> if != 0 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af619f1728a86571713c27778746848cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VRay::VRayRenderer::append </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fileName</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="aa648ca10f3883c261f3982015c293961"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VRay::VRayRenderer::appendAsText </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>text</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Similar to <a class="el" href="class_v_ray_1_1_v_ray_renderer.html#aa5b156d68bda49e3d5cf90b884b998e6">append()</a> but this takes as input directly the text contents of a scene file </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>- no error; check <a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a5df8e0d290de1d52f6e19751a48f92c2" title="Returns the parser error that occurred when a scene was last loaded or appended. ">getLastParserError()</a> if != 0 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7c3a8f75aa7d7c12699c77d9a53f47d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VRay::VRayRenderer::appendAsText </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>text</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="aaad57e3260a9a24698476f4e9ec18cf5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VRay::VRayRenderer::appendAsTextFiltered </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool(*)(<a class="el" href="class_v_ray_1_1_v_ray_renderer.html">VRayRenderer</a> &amp;, const char *pluginType, std::string &amp;pluginName, void *)&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>userData</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Similar to <a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a27e256b80e53e81ef55c3871428593c8">appendFiltered()</a> but this takes as input directly the text contents of a scene file. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>- no error; check <a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a5df8e0d290de1d52f6e19751a48f92c2" title="Returns the parser error that occurred when a scene was last loaded or appended. ">getLastParserError()</a> if != 0 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1841a26d188f423305bdebfd80fad1f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VRay::VRayRenderer::appendAsTextFiltered </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool(*)(<a class="el" href="class_v_ray_1_1_v_ray_renderer.html">VRayRenderer</a> &amp;, const char *pluginType, std::string &amp;pluginName, void *)&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>userData</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a38573cbc7f19bfa2fd877465d44f704e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool(T::*)(VRayRenderer &amp;, const char *pluginType, std::string &amp;pluginName, void *) TMethod&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int VRay::VRayRenderer::appendAsTextFiltered </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>userData</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Similar to <a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a27e256b80e53e81ef55c3871428593c8">appendFiltered()</a> but this takes as input directly the text contents of a scene file. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>- no error; check <a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a5df8e0d290de1d52f6e19751a48f92c2" title="Returns the parser error that occurred when a scene was last loaded or appended. ">getLastParserError()</a> if != 0 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abd4a8403d82dddcc2f26aaacd9ae1543"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool(T::*)(VRayRenderer &amp;, const char *pluginType, std::string &amp;pluginName, void *) TMethod&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int VRay::VRayRenderer::appendAsTextFiltered </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>userData</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a27e256b80e53e81ef55c3871428593c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VRay::VRayRenderer::appendFiltered </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool(*)(<a class="el" href="class_v_ray_1_1_v_ray_renderer.html">VRayRenderer</a> &amp;, const char *pluginType, std::string &amp;pluginName, void *)&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>userData</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Appends the specified scene file data to the currently loaded scene without wiping it. The file can be exported from a previous session with this SDK or from V-Ray for 3dsMax, Maya, etc. A callback function is called for each plugin before it is created in memory. The user can decide whether he wants the plugin to be created or not and whether he wants to change its name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fileName</td><td>The file path to the .vrscene file which will be appended. </td></tr>
    <tr><td class="paramname">callback</td><td>The callback function called for each plugin. Return true if you want the plugin to be created or false otherwise. You can also change the plugin name in the callback. </td></tr>
    <tr><td class="paramname">userData</td><td>A pointer to optional user data which is then passed to the callback function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>- no error; check <a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a5df8e0d290de1d52f6e19751a48f92c2" title="Returns the parser error that occurred when a scene was last loaded or appended. ">getLastParserError()</a> if != 0 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab25e33041f6c2e44111a2df34ed57b36"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VRay::VRayRenderer::appendFiltered </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool(*)(<a class="el" href="class_v_ray_1_1_v_ray_renderer.html">VRayRenderer</a> &amp;, const char *pluginType, std::string &amp;pluginName, void *)&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>userData</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="ae29a1d1916e52cf3030771bdb80c5922"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool(T::*)(VRayRenderer &amp;, const char *pluginType, std::string &amp;pluginName, void *) TMethod&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int VRay::VRayRenderer::appendFiltered </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>userData</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Appends the specified scene file data to the currently loaded scene without wiping it. The file can be exported from a previous session with this SDK or from V-Ray for 3dsMax, Maya, etc. A callback function is called for each plugin before it is created in memory. The user can decide whether he wants the plugin to be created or not and whether he wants to change its name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>The type of the object containing a callback memeber function. </td></tr>
    <tr><td class="paramname">TMethod</td><td>A pointer to the callback member function. Return true if you want the plugin to be created or false otherwise. You can also change the plugin name in the callback. </td></tr>
    <tr><td class="paramname">fileName</td><td>The file path to the .vrscene file which will be appended. </td></tr>
    <tr><td class="paramname">obj</td><td>The object containing the callback member function called for each plugin. </td></tr>
    <tr><td class="paramname">userData</td><td>A pointer to optional user data which is then passed to the callback function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>- no error; check <a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a5df8e0d290de1d52f6e19751a48f92c2" title="Returns the parser error that occurred when a scene was last loaded or appended. ">getLastParserError()</a> if != 0 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7ca50e4f468375d5c4efa914a7dc808d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool(T::*)(VRayRenderer &amp;, const char *pluginType, std::string &amp;pluginName, void *) TMethod&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int VRay::VRayRenderer::appendFiltered </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>userData</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a738657cec4adecfff74cb0eb2cac2fe6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VRay::VRayRenderer::bucketRenderNearest </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>When using the bucket sampler in production mode this sets a "focus point" for the follow mouse cursor feature of the <a class="el" href="class_v_ray_1_1_v_ray_renderer_1_1_v_f_b.html" title="This class groups all VFB related methods. ">VFB</a>. This API allows you to do this without the <a class="el" href="class_v_ray_1_1_v_ray_renderer_1_1_v_f_b.html" title="This class groups all VFB related methods. ">VFB</a>. Buckets are generated in a circle outward from the point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The x-coordinate of the focus point. If set to negative this will reset the "follow cursor" behavior and continue with the normal bucket generator. </td></tr>
    <tr><td class="paramname">y</td><td>The y-coordinate of the focus point. If set to negative this will reset the "follow cursor" behavior and continue with the normal bucket generator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a89b30cc3d6647da7c2712304705b4f64"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VRay::VRayRenderer::commit </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force</em> = <code>false</code>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Commits any accumulated scene changes. This is necessary if the autoCommit flag is set to false. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">force</td><td>If true, immediate flush commit is forced. Generally this should not be set to true. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the changes were sucessfully committed, false otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3191f9c211050ab354ead75a3906cbc6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VRay::VRayRenderer::createCombinedProxyFileMesh </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_v_ray_1_1_plugin.html">Plugin</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>geomStaticMeshPlugins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_v_ray_1_1_transform.html">Transform</a> &gt; *&#160;</td>
          <td class="paramname"><em>transforms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_v_ray_1_1_proxy_create_params.html">ProxyCreateParams</a> &amp;&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">geomStaticMeshPlugins</td><td>An array of GeomStaticMesh instances to combine in the proxy file as one mesh </td></tr>
    <tr><td class="paramname">transforms</td><td>Transformations for the separate input meshes to bake into the final mesh. Size must equal the mesh array size. Pass NULL to skip. </td></tr>
    <tr><td class="paramname">params</td><td>A <a class="el" href="struct_v_ray_1_1_proxy_create_params.html" title="Used by VRayRenderer::createProxyFileMesh() ">ProxyCreateParams</a> container for the various parameters, including file name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if an error ocurred. Check <a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a9e162e2277748e2a68fbb81f1218cf9d" title="Returns the last error that occurred when a method was called. Use this to understand why a method re...">getLastError()</a> for additional info. Will return false without "last error" set if a transform array of mismatching size is passed. </dd></dl>

</div>
</div>
<a class="anchor" id="a41c6a341512c69cdceca038af7176b88"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VRay::VRayRenderer::createProxyFileMesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_v_ray_1_1_plugin.html">Plugin</a> &amp;&#160;</td>
          <td class="paramname"><em>geomStaticMeshPlugin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_v_ray_1_1_transform.html">Transform</a> *&#160;</td>
          <td class="paramname"><em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_v_ray_1_1_proxy_create_params.html">ProxyCreateParams</a> &amp;&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">geomStaticMeshPlugin</td><td>A GeomStaticMesh instance supplying the data for the proxy file </td></tr>
    <tr><td class="paramname">transform</td><td>A transformation to bake into the geometry data. Pass NULL to skip. </td></tr>
    <tr><td class="paramname">params</td><td>A <a class="el" href="struct_v_ray_1_1_proxy_create_params.html" title="Used by VRayRenderer::createProxyFileMesh() ">ProxyCreateParams</a> container for the various parameters, including file name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if an error ocurred. Check <a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a9e162e2277748e2a68fbb81f1218cf9d" title="Returns the last error that occurred when a method was called. Use this to understand why a method re...">getLastError()</a> for additional info. </dd></dl>

</div>
</div>
<a class="anchor" id="aecce95f4936fbef91554a33e5db1fc54"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VRay::VRayRenderer::denoiseNow </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Explicitly starts the denoiser. Requires a RenderChannelDenoiser instance in the scene. This can be run while rendering is ongoing or when it's paused or after it is stopped. Denoising parameters are taken from the RenderChannelDenoiser plugin. The denoising is run asynchronously, so this function will return as soon as the thread is started. When denoising is done the postEffectsUpdated callback will be called. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the denoising thread is started successfully and false if there is a problem with the parameters or renderer state </dd></dl>

</div>
</div>
<a class="anchor" id="abb19ad37026282797658b036936263d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VRay::VRayRenderer::exportScene </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filePath</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exports the current scene contents to the specified file. The exporter serializes all plugins in text format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filePath</td><td>The path to the file where the scene will be exported. The file path must contain the name and extension of the destination file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>- no error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6bbe72781303d3375aef24c4e08db66e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VRay::VRayRenderer::exportScene </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filePath</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="aacd965e58058c5020d20e86a046f3487"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VRay::VRayRenderer::exportScene </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_v_ray_1_1_v_ray_export_settings.html">VRayExportSettings</a> &amp;&#160;</td>
          <td class="paramname"><em>settings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exports the current scene contents to the specified file. The exporter serializes all plugins in text format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filePath</td><td>The path to the file where the scene will be exported. The file path must contain the name and extension of the destination file. </td></tr>
    <tr><td class="paramname">settings</td><td>Additional options such as compression and file splitting </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>- no error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a73077d94c3874b82c03529756684921c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VRay::VRayRenderer::exportScene </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_v_ray_1_1_v_ray_export_settings.html">VRayExportSettings</a> &amp;&#160;</td>
          <td class="paramname"><em>settings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="ad3d4d41990b01a0da532591c9bc141c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string VRay::VRayRenderer::getActiveHosts </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns all active hosts during distributed rendering. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">semicolon</td><td>separated string of IP:port (or hostname:port) pairs </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad2b60dc969bac1d7376bc3bd2c408d8d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string VRay::VRayRenderer::getAllHosts </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns all hosts set for distributed rendering. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">semicolon</td><td>separated string of IP:port (or hostname:port) pairs </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a85695b30bb0c598223933ec7f70a9bfc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t VRay::VRayRenderer::getCausticsSize </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The size in bytes of the caustics photon map in memory. This is 0 if no data is available. </dd></dl>

</div>
</div>
<a class="anchor" id="a220b7cc51f5bbb4a2134ef6af808cfac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="struct_v_ray_1_1_compute_device_info.html">ComputeDeviceInfo</a>&gt; VRay::VRayRenderer::getComputeDevicesCUDA </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a list of all devices available for use by the CUDA engine. The "C++/CPU" device uses the CUDA engine code compiled for the x86-64 architecture. It is <em>not</em> the CPU V-Ray engine. It is disabled by default but you can enable it for faster "hybrid" rendering. </p>
<dl class="section return"><dt>Returns</dt><dd>If the list is empty, check <a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a9e162e2277748e2a68fbb81f1218cf9d" title="Returns the last error that occurred when a method was called. Use this to understand why a method re...">getLastError()</a> for failure. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd>struct <a class="el" href="struct_v_ray_1_1_compute_device_info.html" title="Used for GPU device selection by VRayRenderer::getComputeDevicesCurrentEngine() &amp; co...">ComputeDeviceInfo</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af361640faf5882a193649b2902a1c51e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="struct_v_ray_1_1_compute_device_info.html">ComputeDeviceInfo</a>&gt; VRay::VRayRenderer::getComputeDevicesCurrentEngine </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a list of all devices available for use by the current engine (CUDA or OpenCL). </p>
<dl class="section return"><dt>Returns</dt><dd>If the list is empty, check <a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a9e162e2277748e2a68fbb81f1218cf9d" title="Returns the last error that occurred when a method was called. Use this to understand why a method re...">getLastError()</a> for failure. The list will be empty without error if the current render mode is CPU. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd>struct <a class="el" href="struct_v_ray_1_1_compute_device_info.html" title="Used for GPU device selection by VRayRenderer::getComputeDevicesCurrentEngine() &amp; co...">ComputeDeviceInfo</a> </dd></dl>

</div>
</div>
<a class="anchor" id="abbbdeee7ba35a6c6e594639a30dcf587"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="struct_v_ray_1_1_compute_device_info.html">ComputeDeviceInfo</a>&gt; VRay::VRayRenderer::getComputeDevicesOpenCL </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a list of all devices available for use by the OpenCL engine. </p>
<dl class="section return"><dt>Returns</dt><dd>If the list is empty, check <a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a9e162e2277748e2a68fbb81f1218cf9d" title="Returns the last error that occurred when a method was called. Use this to understand why a method re...">getLastError()</a> for failure. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd>struct <a class="el" href="struct_v_ray_1_1_compute_device_info.html" title="Used for GPU device selection by VRayRenderer::getComputeDevicesCurrentEngine() &amp; co...">ComputeDeviceInfo</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a433b2c0d6bc6a5cae1f686381c4d71e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_v_ray_1_1_v_ray_image.html">VRayImage</a>* VRay::VRayRenderer::getImage </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a pointer to a copy of the image contained in the renderer image buffer at this moment. The user is responsible for deleting it. </p>

</div>
</div>
<a class="anchor" id="a384615b4231c48a2b0f396d42e20d34a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_v_ray_1_1_v_ray_image.html">VRayImage</a>* VRay::VRayRenderer::getImage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_v_ray_1_1_get_image_options.html">GetImageOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a pointer to a copy of the image contained in the renderer image buffer at this moment. The user is responsible for deleting it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">options</td><td>Use to modify behavior compared to <a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a433b2c0d6bc6a5cae1f686381c4d71e9">getImage(void)</a> - crop, color correct, etc. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab06480d098351ed0b47029c22ae2e500"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string VRay::VRayRenderer::getInactiveHosts </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns all inactive hosts during distributed rendering. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">semicolon</td><td>separated string of IP:port (or hostname:port) pairs </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a08adbdf876087124f9f47aecdad0263b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_v_ray_1_1_plugin.html">Plugin</a> VRay::VRayRenderer::getInstanceOf </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pluginType</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the (last) instance of a given plugin type if available. Should be used for singleton plugins. Settings plugins are singletons. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pluginType</td><td>The plugin class name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">The</td><td>plugin instance which may be invalid if one does not exist. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abb42abb13ce1bcbbc6ea45f67178596e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_v_ray_1_1_plugin.html">Plugin</a> VRay::VRayRenderer::getInstanceOf </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pluginType</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a216660b6220fd2c068f16afb69c30131"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T VRay::VRayRenderer::getInstanceOf </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a710f9e9244a0b39e2e16a3b49cc788ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_v_ray_1_1_plugin.html">Plugin</a> VRay::VRayRenderer::getInstanceOrCreate </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pluginType</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the (last) instance of a given plugin type or creates a new instance if not available. Should be used for singleton plugins. Settings plugins are singletons. Use <a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a5093e03131eca8fc961cf136b438fb04">getOrCreatePlugin()</a> for other plugin types. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pluginType</td><td>The plugin class name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">The</td><td>plugin instance which may be invalid if one does not exist. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae2595cafce1c8423ac1042fdaaddfe54"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_v_ray_1_1_plugin.html">Plugin</a> VRay::VRayRenderer::getInstanceOrCreate </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pluginType</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="ac0f92773090da07d04bd6f0d13c53c07"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T VRay::VRayRenderer::getInstanceOrCreate </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a24d319d0406139703baefb026ca9da05"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_v_ray_1_1_plugin.html">Plugin</a> VRay::VRayRenderer::getInstanceOrCreate </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pluginName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pluginType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a plugin instance of the given type if available or creates a new one with the given name and of the given type if not. Should be used for singleton plugins. Settings plugins are singletons. Use <a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a5093e03131eca8fc961cf136b438fb04">getOrCreatePlugin()</a> for other plugin types. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pluginName</td><td>The plugin instance name if it has to be created. </td></tr>
    <tr><td class="paramname">pluginType</td><td>The plugin class name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">The</td><td>plugin instance which may be invalid if one does not exist. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9e76ec9948dff5619813d7e87b73e2fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_v_ray_1_1_plugin.html">Plugin</a> VRay::VRayRenderer::getInstanceOrCreate </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pluginName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pluginType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a869f5b94e8e22647bd3f661b8d401f85"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_v_ray_1_1_plugin.html">Plugin</a> VRay::VRayRenderer::getInstanceOrCreate </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pluginName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pluginType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a80011c6e6556c31efac04b345aa9bffd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_v_ray_1_1_plugin.html">Plugin</a> VRay::VRayRenderer::getInstanceOrCreate </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pluginName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pluginType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a479b02ee4628bce12db3e61fa5990f81"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T VRay::VRayRenderer::getInstanceOrCreate </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pluginName</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a16965b7419e39b199b31c5fdb029db7b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T VRay::VRayRenderer::getInstanceOrCreate </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pluginName</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="aac218ba0d12009938d45d60a2b51ed9f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t VRay::VRayRenderer::getIrradianceMapSize </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The size in bytes of the irradiance map in memory. This is 0 if no IM is available. </dd></dl>

</div>
</div>
<a class="anchor" id="a1233f32aa8a7f86b00e8012d84c29064"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t VRay::VRayRenderer::getLightCacheSize </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The size in bytes of the light cache in memory. This is 0 if no LC is available. </dd></dl>

</div>
</div>
<a class="anchor" id="a5093e03131eca8fc961cf136b438fb04"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_v_ray_1_1_plugin.html">Plugin</a> VRay::VRayRenderer::getOrCreatePlugin </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pluginName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pluginType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a plugin instance with the given instance name and of the given type. A new instance is created if one does not exist with the given name. For singleton plugins like the settings plugins use <a class="el" href="class_v_ray_1_1_v_ray_renderer.html#ac0f92773090da07d04bd6f0d13c53c07">getInstanceOrCreate()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pluginName</td><td>The plugin instance name. </td></tr>
    <tr><td class="paramname">pluginType</td><td>The plugin class name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">The</td><td>plugin instance which should not be invalid unless the plugin type is not available. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae30fd2c65ab6a1bcd5478975bdf5b4a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_v_ray_1_1_plugin.html">Plugin</a> VRay::VRayRenderer::getOrCreatePlugin </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pluginName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pluginType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="ac75c04515d971dba592f7d0a0591179e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_v_ray_1_1_plugin.html">Plugin</a> VRay::VRayRenderer::getOrCreatePlugin </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pluginName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pluginType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="aadec07432c6d3b1d14cd9809815cb7a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_v_ray_1_1_plugin.html">Plugin</a> VRay::VRayRenderer::getOrCreatePlugin </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pluginName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pluginType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a10c2630eb675945b82a01b94ae4a0bab"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T VRay::VRayRenderer::getOrCreatePlugin </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pluginName</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a9bee46faa649e74b2aaad7d7359e9846"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t VRay::VRayRenderer::getPhotonMapSize </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The size in bytes of the global photon map in memory. This is 0 if no PM is available. </dd></dl>

</div>
</div>
<a class="anchor" id="a5258af41f75dbc92d5945c3cc84eca83"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_v_ray_1_1_plugin.html">Plugin</a> VRay::VRayRenderer::getPlugin </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pluginName</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Search for a plugin instance with the given name. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Invalid</td><td><a class="el" href="class_v_ray_1_1_plugin.html">Plugin</a> object if not found. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a31659ad9a9cbce9b04af0fe13fff61a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_v_ray_1_1_plugin.html">Plugin</a> VRay::VRayRenderer::getPlugin </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pluginName</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a43c1b9915eaa193a1e37deffbd23ac74"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T VRay::VRayRenderer::getPlugin </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pluginName</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a99ddd33a9d1bc06a0b641b7ca8c21276"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T VRay::VRayRenderer::getPlugin </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pluginName</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="aaab4ebeb52130cd42921b113303e72ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="class_v_ray_1_1_plugin.html">Plugin</a>&gt; VRay::VRayRenderer::getPlugins </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pluginClassName</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="aac0e0d149298a1198b6afd576a7e61d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="class_v_ray_1_1_plugin.html">Plugin</a>&gt; VRay::VRayRenderer::getPlugins </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pluginClassName</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a774aebbb18ac28bb080f3f25224d4c77"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VRay::VRayRenderer::getRenderRegion </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>rgnLeft</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>rgnTop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>rgnWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>rgnHeight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the rendering region within the image width and height. (width and height are the rendering sizes set by other methods or constructors, etc.) </p>

</div>
</div>
<a class="anchor" id="ab5c4e0269527ae1c52bb372210a1ea4c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RendererState VRay::VRayRenderer::getState </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the current state of the renderer. </p>
<dl class="section note"><dt>Note</dt><dd>The state could change asynchronously as rendering occurs in another thread. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd>RendererState </dd></dl>

</div>
</div>
<a class="anchor" id="a966c91d52a74e1730196dd77490cd6b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VRay::VRayRenderer::isAborted </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns if the rendering has been aborted. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the user has clicked on the Stop button in <a class="el" href="class_v_ray_1_1_v_ray_renderer_1_1_v_f_b.html" title="This class groups all VFB related methods. ">VFB</a>, false otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a67aff084d561a4177434a04891d6db1a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VRay::VRayRenderer::isImageReady </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if rendering is complete. If it ended in failure or got cancelled, this will still return true. Notice that an intermediate image may be available from getImage even if this returns false (because rendering is ongoing). </p>
<dl class="section remark"><dt>Remarks</dt><dd>It is recommended to use waitForImageReady instead of polling this in a loop. </dd></dl>

</div>
</div>
<a class="anchor" id="a37b4f4988009867a30bfabe54a4271b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VRay::VRayRenderer::isSequenceDone </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the status of the sequence rendering process. This is not meaningful if you're not rendering a sequence. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the whole sequence has been rendered, false otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2a36db37a7b22494ff7d2fd85b39c9fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VRay::VRayRenderer::load </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fileName</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Loads the specified V-Ray scene file (.vrscene) into memory. Previous scene contents are wiped. The file can be exported from a previous session with this SDK or from V-Ray for 3dsMax, Maya, etc. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fileName</td><td>The file path to the .vrscene file which will be loaded. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>- no error; check <a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a5df8e0d290de1d52f6e19751a48f92c2" title="Returns the parser error that occurred when a scene was last loaded or appended. ">getLastParserError()</a> if != 0 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a113c43b383295d0b4821618aa10aeaa7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VRay::VRayRenderer::load </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fileName</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="af8ea5a15de2b05802a6280cdd67ce795"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VRay::VRayRenderer::loadAsText </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>text</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Similar to <a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a2a36db37a7b22494ff7d2fd85b39c9fe">load()</a> but this takes as input directly the text contents of a scene file </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>- no error; check <a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a5df8e0d290de1d52f6e19751a48f92c2" title="Returns the parser error that occurred when a scene was last loaded or appended. ">getLastParserError()</a> if != 0 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4d6b2797472bb0a4ba499ac8af8d5c86"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VRay::VRayRenderer::loadAsText </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>text</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a1d47f7ef848907ffab753ad8f85b3a4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VRay::VRayRenderer::loadAsTextFiltered </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool(*)(<a class="el" href="class_v_ray_1_1_v_ray_renderer.html">VRayRenderer</a> &amp;, const char *pluginType, std::string &amp;pluginName, void *)&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>userData</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Similar to <a class="el" href="class_v_ray_1_1_v_ray_renderer.html#aa24f282ac349c21afaf5ed756c9c77de">loadFiltered()</a> but this takes as input directly the text contents of a scene file. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>- no error; check <a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a5df8e0d290de1d52f6e19751a48f92c2" title="Returns the parser error that occurred when a scene was last loaded or appended. ">getLastParserError()</a> if != 0 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a57d05df739683ad6ec5370042e115efb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VRay::VRayRenderer::loadAsTextFiltered </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool(*)(<a class="el" href="class_v_ray_1_1_v_ray_renderer.html">VRayRenderer</a> &amp;, const char *pluginType, std::string &amp;pluginName, void *)&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>userData</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a0692856bcb43b792a8fdd631ccf01e1e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool(T::*)(VRayRenderer &amp;, const char *pluginType, std::string &amp;pluginName, void *) TMethod&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int VRay::VRayRenderer::loadAsTextFiltered </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>userData</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Similar to <a class="el" href="class_v_ray_1_1_v_ray_renderer.html#aa24f282ac349c21afaf5ed756c9c77de">loadFiltered()</a> but this takes as input directly the text contents of a scene file. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>- no error; check <a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a5df8e0d290de1d52f6e19751a48f92c2" title="Returns the parser error that occurred when a scene was last loaded or appended. ">getLastParserError()</a> if != 0 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a49391df3c350bdff45f39b8961f455ba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool(T::*)(VRayRenderer &amp;, const char *pluginType, std::string &amp;pluginName, void *) TMethod&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int VRay::VRayRenderer::loadAsTextFiltered </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>userData</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="aa24f282ac349c21afaf5ed756c9c77de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VRay::VRayRenderer::loadFiltered </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool(*)(<a class="el" href="class_v_ray_1_1_v_ray_renderer.html">VRayRenderer</a> &amp;, const char *pluginType, std::string &amp;pluginName, void *)&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>userData</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Loads the specified V-Ray scene file (.vrscene) into memory. Previous scene contents are wiped. The file can be exported from a previous session with this SDK or from V-Ray for 3dsMax, Maya, etc. A callback function is called for each plugin before it is created in memory. The user can decide whether he wants the plugin to be created or not and whether he wants to change its name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fileName</td><td>The file path to the .vrscene file which will be loaded. </td></tr>
    <tr><td class="paramname">callback</td><td>The callback function called for each plugin. Return true if you want the plugin to be created or false otherwise. You can also change the plugin name in the callback. </td></tr>
    <tr><td class="paramname">userData</td><td>A pointer to optional user data which is then passed to the callback function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>- no error; check <a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a5df8e0d290de1d52f6e19751a48f92c2" title="Returns the parser error that occurred when a scene was last loaded or appended. ">getLastParserError()</a> if != 0 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab7933067177d5ab27153b857bc905eed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VRay::VRayRenderer::loadFiltered </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool(*)(<a class="el" href="class_v_ray_1_1_v_ray_renderer.html">VRayRenderer</a> &amp;, const char *pluginType, std::string &amp;pluginName, void *)&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>userData</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="ac7c4add2a63195cd912cd0da2159194c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool(T::*)(VRayRenderer &amp;, const char *pluginType, std::string &amp;pluginName, void *) TMethod&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int VRay::VRayRenderer::loadFiltered </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>userData</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Loads the specified V-Ray scene file (.vrscene) into memory. Previous scene contents are wiped. The file can be exported from a previous session with this SDK or from V-Ray for 3dsMax, Maya, etc. A callback function is called for each plugin before it is created in memory. The user can decide whether he wants the plugin to be created or not and whether he wants to change its name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>The type of the object containing a callback memeber function. </td></tr>
    <tr><td class="paramname">TMethod</td><td>A pointer to the callback member function. Return true if you want the plugin to be created or false otherwise. You can also change the plugin name in the callback. </td></tr>
    <tr><td class="paramname">fileName</td><td>The file path to the .vrscene file which will be loaded. </td></tr>
    <tr><td class="paramname">obj</td><td>The object containing the callback member function called for each plugin. </td></tr>
    <tr><td class="paramname">userData</td><td>A pointer to optional user data which is then passed to the callback function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>- no error; check <a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a5df8e0d290de1d52f6e19751a48f92c2" title="Returns the parser error that occurred when a scene was last loaded or appended. ">getLastParserError()</a> if != 0 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af1201854b2554a938d6e62348bc48a8f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool(T::*)(VRayRenderer &amp;, const char *pluginType, std::string &amp;pluginName, void *) TMethod&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int VRay::VRayRenderer::loadFiltered </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>userData</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a4229096092ef1f136416c57b23c6dee4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_v_ray_1_1_plugin.html">Plugin</a> VRay::VRayRenderer::newPlugin </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pluginName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pluginType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates an instance of a specific <a class="el" href="class_v_ray_1_1_plugin.html">Plugin</a> type with the given instance name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pluginName</td><td>The plugin name. </td></tr>
    <tr><td class="paramname">pluginType</td><td>The plugin class name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">The</td><td>new plugin instance (an invalid <a class="el" href="class_v_ray_1_1_plugin.html">Plugin</a> on error). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab392b36cd7dff6d95a630b448369a204"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_v_ray_1_1_plugin.html">Plugin</a> VRay::VRayRenderer::newPlugin </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pluginName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pluginType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="adcc13be418f1e76bf8238aec79701d42"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_v_ray_1_1_plugin.html">Plugin</a> VRay::VRayRenderer::newPlugin </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pluginName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pluginType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="ab405aa3163d6d27cb2e76372f17a702e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_v_ray_1_1_plugin.html">Plugin</a> VRay::VRayRenderer::newPlugin </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pluginName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pluginType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a668726573f9683584db2d0552abdf092"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T VRay::VRayRenderer::newPlugin </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pluginName</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="ae5bc74e164a1aa9132d4c0b0f10427f5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T VRay::VRayRenderer::newPlugin </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pluginName</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a3e059ebd191ddafdb66872db3b904148"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_v_ray_1_1_plugin.html">Plugin</a> VRay::VRayRenderer::newPlugin </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pluginType</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates an instance of a specific <a class="el" href="class_v_ray_1_1_plugin.html">Plugin</a> type with an autogenerated instance name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pluginType</td><td>The plugin class name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">The</td><td>new plugin instance (an invalid <a class="el" href="class_v_ray_1_1_plugin.html">Plugin</a> on error). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a77d134d37a20a20188c898a750b198c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_v_ray_1_1_plugin.html">Plugin</a> VRay::VRayRenderer::newPlugin </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pluginType</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="ac92514f42ebe4bb9d2b54eb227ecd94d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T VRay::VRayRenderer::newPlugin </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a11136843d8dbfa656c5b5f3f02989199"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VRay::VRayRenderer::operator bool </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If exceptions are not enabled use this function to test whether you have a valid renderer </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>- renderer instance is valid, false - renderer instance is invalid </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a72045eeaa88d855a505216c87a05822d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_v_ray_1_1_plugin.html">Plugin</a> VRay::VRayRenderer::pickPlugin </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the first scene Node intersected by tracing a camera ray from image space coordinates (x;y), if any </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Image space X </td></tr>
    <tr><td class="paramname">y</td><td>Image space Y </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aacd27088c3c6f2b56db0ff2688a5bed8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_v_ray_1_1_plugin.html">Plugin</a> VRay::VRayRenderer::pickPlugin </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the first scene Node intersected by tracing a camera ray from image space coordinates (x;y), if any </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Image space X </td></tr>
    <tr><td class="paramname">y</td><td>Image space Y </td></tr>
    <tr><td class="paramname">timeout</td><td>Maximum milliseconds to spend before returning a result </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1a38dd2e14ca6a5aa9f1b3660f02601c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="struct_v_ray_1_1_plugin_distance_pair.html">PluginDistancePair</a>&gt; VRay::VRayRenderer::pickPlugins </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxcount</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a list of scene Node intersected by tracing a camera ray from image space coordinates (x;y) ordered by depth </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Image space X </td></tr>
    <tr><td class="paramname">y</td><td>Image space Y </td></tr>
    <tr><td class="paramname">maxcount</td><td>Maximum number of nodes to include in the list </td></tr>
    <tr><td class="paramname">timeout</td><td>Maximum milliseconds to spend before returning a result </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab04696524b30104dfdbfbfe010164bb4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VRay::VRayRenderer::pluginExists </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pluginName</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if a plugin with the given instance name exists in the current scene </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">bool</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5d53afa95c08290c2bb1112e496af1eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VRay::VRayRenderer::pluginExists </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pluginName</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a560b74d4e4b2775fd0d188ae658b87e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VRay::VRayRenderer::readProxyFullData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_v_ray_1_1_plugin.html">Plugin</a> &amp;&#160;</td>
          <td class="paramname"><em>proxyPlugin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_v_ray_1_1_proxy_read_data.html">ProxyReadData</a> &amp;&#160;</td>
          <td class="paramname"><em>readData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxyPlugin</td><td>A GeomMeshFile plugin instance to read the file path and parameters from. </td></tr>
    <tr><td class="paramname">readData</td><td>A structure defining which parts of the data to read (with .setFlags()) and holding the resulting arrays. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if an error ocurred. Check <a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a9e162e2277748e2a68fbb81f1218cf9d" title="Returns the last error that occurred when a method was called. Use this to understand why a method re...">getLastError()</a> for additional info. </dd></dl>

</div>
</div>
<a class="anchor" id="ad32e0cfdc64ceabcdcf5d2f52c8eded9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VRay::VRayRenderer::readProxyPreviewGeometry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_v_ray_1_1_plugin.html">Plugin</a> &amp;&#160;</td>
          <td class="paramname"><em>proxyPlugin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorList &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntList &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>countHint</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxyPlugin</td><td>A GeomMeshFile plugin instance to read the file path and parameters from. </td></tr>
    <tr><td class="paramname">vertices</td><td>Output vertex preview data. The array can be passed on directly to DirectX/OpenGL etc. (and the indices too) </td></tr>
    <tr><td class="paramname">indices</td><td>Output face index data. Each three consecutive elements in make up one triangle. </td></tr>
    <tr><td class="paramname">countHint</td><td>[Alembic only] An optional number of triangles to return. The exact number of elements in 'vertices' may differ slightly. If countHint is not specified, proxyPlugin::num_preview_faces is used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af54ed5c48c75b77d2680de9ff8f0bb7e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VRay::VRayRenderer::readProxyPreviewHair </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_v_ray_1_1_plugin.html">Plugin</a> &amp;&#160;</td>
          <td class="paramname"><em>proxyPlugin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorList &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntList &amp;&#160;</td>
          <td class="paramname"><em>lengths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>countHint</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxyPlugin</td><td>A GeomMeshFile plugin instance to read the file path and parameters from. </td></tr>
    <tr><td class="paramname">vertices</td><td>Output vertex preview data. Consecutive vertices form hair strands. The i-th strand has lengths[i] consecutive vertices. </td></tr>
    <tr><td class="paramname">lengths</td><td>Output hair strand length data. Each strand can have a different number of vertices. </td></tr>
    <tr><td class="paramname">countHint</td><td>[Alembic only] The number of hair strands to return. The exact number of elements in 'lengths' may differ slightly. If countHint is not specified, proxyPlugin::num_preview_faces is used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a52549b385db790505fcad4ca87d2bb09"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VRay::VRayRenderer::readProxyPreviewParticles </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_v_ray_1_1_plugin.html">Plugin</a> &amp;&#160;</td>
          <td class="paramname"><em>proxyPlugin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorList &amp;&#160;</td>
          <td class="paramname"><em>positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>countHint</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxyPlugin</td><td>A GeomMeshFile plugin instance to read the file path and parameters from. </td></tr>
    <tr><td class="paramname">positions</td><td>Output particle preview data. The positions of the preview subset of all particles. </td></tr>
    <tr><td class="paramname">countHint</td><td>[Alembic only] An optional number of particles to return. The exact number of elements in 'positions' may differ slightly. If countHint is not specified, proxyPlugin::num_preview_faces is used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a57b5c2de16f23c90b541a38e2606be36"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VRay::VRayRenderer::removeHosts </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>hosts</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disconnects and removes hosts from the distributed rendering host lists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hosts</td><td>IP:port (or hostname:port) pairs as string delimited by ',' or ';' </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>- no error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae850e272778f838de4a46410fc51d245"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VRay::VRayRenderer::removeHosts </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>hosts</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="ac2fa24e78b2140c3c45732d3f778469c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VRay::VRayRenderer::removePlugin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_v_ray_1_1_plugin.html">Plugin</a> &amp;&#160;</td>
          <td class="paramname"><em>plugin</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove the plugin from the scene. The <a class="el" href="class_v_ray_1_1_plugin.html">Plugin</a> object becomes invalid if the call is successful. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if removal was successful </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa2f6182012fa704641e25071c2c872d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VRay::VRayRenderer::removePlugin </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pluginName</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove the plugin from the scene. <a class="el" href="class_v_ray_1_1_plugin.html">Plugin</a> object handles becomes invalid if the call is successful. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if removal was successful </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a16218b4522c7997f3c02d4d3200619b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VRay::VRayRenderer::removePlugin </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pluginName</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove the plugin from the scene. <a class="el" href="class_v_ray_1_1_plugin.html">Plugin</a> object handles becomes invalid if the call is successful. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if removal was successful </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aac871054ee4cae5148298abc8da5aae4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VRay::VRayRenderer::renderSequence </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_v_ray_1_1_sub_sequence_desc.html">SubSequenceDesc</a>&#160;</td>
          <td class="paramname"><em>descriptions</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Begins rendering an animation sequence in a separate thread. A non-blocking call. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">descriptions</td><td>Frame ranges to render </td></tr>
    <tr><td class="paramname">count</td><td>The number of elements in descriptions </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaac68504d2fc4c9189a1c483469eb8b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VRay::VRayRenderer::replacePlugin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_v_ray_1_1_plugin.html">Plugin</a> &amp;&#160;</td>
          <td class="paramname"><em>oldPlugin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_v_ray_1_1_plugin.html">Plugin</a> &amp;&#160;</td>
          <td class="paramname"><em>newPlugin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Replaces all references (in the scene) of oldPlugin with newPlugin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oldPlugin</td><td>The plugin whose references are to be replaced. </td></tr>
    <tr><td class="paramname">newPlugin</td><td>The plugin which will replace the old one. This can be an empty Plugin() in which case all references to oldPlugin will be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>on success, flase on failure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The oldPlugin does not get removed from the scene by this call </dd></dl>

</div>
</div>
<a class="anchor" id="a32e571b68b8de7ab23463a8258797c7c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VRay::VRayRenderer::resetHosts </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>hosts</em> = <code>NULL</code>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resets the hosts list for distributed rendering. If rendering is in process, hosts that are not on the new list are disconnected. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hosts</td><td>IP:port (or hostname:port) pairs as string delimited by ',' or ';' </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>- no error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a73b6045d3aa3227e033f7d90dc2e3263"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VRay::VRayRenderer::resetHosts </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>hosts</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a55999e7633f3d160de4e8aed7c4917fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VRay::VRayRenderer::saveCausticsFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fileName</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fileName</td><td>Destination caustics photon map file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if an error ocurred or there is no data to save. Check <a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a9e162e2277748e2a68fbb81f1218cf9d" title="Returns the last error that occurred when a method was called. Use this to understand why a method re...">getLastError()</a> for additional info. </dd></dl>

</div>
</div>
<a class="anchor" id="a448af494ba7ff2f82cc99f3cd6bba381"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VRay::VRayRenderer::saveCausticsFile </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fileName</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="abdf58f4321b4eac46bbc10ba5e8913f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VRay::VRayRenderer::saveImage </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fileName</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Save the current image buffer as if you used the save button on the <a class="el" href="class_v_ray_1_1_v_ray_renderer_1_1_v_f_b.html" title="This class groups all VFB related methods. ">VFB</a>. Format is deduced from the filename extension. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">True</td><td>on success </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a541585be484094b0e669c912549ba016"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VRay::VRayRenderer::saveImage </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fileName</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a7232bc1626c85e5124b2a6039c7e59ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VRay::VRayRenderer::saveImage </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_v_ray_1_1_image_writer_options.html">ImageWriterOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Save the current image buffer as if you used the save button on the <a class="el" href="class_v_ray_1_1_v_ray_renderer_1_1_v_f_b.html" title="This class groups all VFB related methods. ">VFB</a>. Format is deduced from the filename extension. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fileName</td><td>Output file name </td></tr>
    <tr><td class="paramname">options</td><td>Additional options for writing </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a585e64ae8f0718481023362c3f626104"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VRay::VRayRenderer::saveImage </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_v_ray_1_1_image_writer_options.html">ImageWriterOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="abf676993996bc2bebe41de6faea487fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VRay::VRayRenderer::saveIrradianceMapFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fileName</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fileName</td><td>Destination irradiance map file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if an error ocurred or there is no data to save. Check <a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a9e162e2277748e2a68fbb81f1218cf9d" title="Returns the last error that occurred when a method was called. Use this to understand why a method re...">getLastError()</a> for additional info. </dd></dl>

</div>
</div>
<a class="anchor" id="acf83cb79f4912586c7c4982a82cedc28"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VRay::VRayRenderer::saveIrradianceMapFile </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fileName</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a5eb353f94a5b7969bab4c68d8b683f6b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VRay::VRayRenderer::saveLightCacheFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fileName</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fileName</td><td>Destination light cache file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if an error ocurred or there is no data to save. Check <a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a9e162e2277748e2a68fbb81f1218cf9d" title="Returns the last error that occurred when a method was called. Use this to understand why a method re...">getLastError()</a> for additional info. </dd></dl>

</div>
</div>
<a class="anchor" id="aad7e691810211b102d26fd08d79ea040"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VRay::VRayRenderer::saveLightCacheFile </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fileName</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="aa4287d85bc13e4c7d96be3a86cc53918"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VRay::VRayRenderer::savePhotonMapFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fileName</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fileName</td><td>Destination global photon map file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if an error ocurred or there is no data to save. Check <a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a9e162e2277748e2a68fbb81f1218cf9d" title="Returns the last error that occurred when a method was called. Use this to understand why a method re...">getLastError()</a> for additional info. </dd></dl>

</div>
</div>
<a class="anchor" id="a16eeda5b462c42f16ef936e7e3c21187"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VRay::VRayRenderer::savePhotonMapFile </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fileName</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a624e6cef1e64fa632e8676864470fa54"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VRay::VRayRenderer::serializeScene </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Serializes the whole scene (plugins with their property values) contained in the renderer into a single memory stream no matter if they originate from a loaded or appended vrscene file or are created by code. The whole stream will be always transferred when DR hosts are connected. No DR hosts should have been connected before serialization. (Currently only one type of serialization is supported but other types may be added in the future.) This method is here mainly for debug purposes but it can be helpful in some other cases as well. Do not use it unless you know exactly what you're doing. </p>

</div>
</div>
<a class="anchor" id="ac30e6eabda89b6b2ae078d664a3b40bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VRay::VRayRenderer::setAutoCommit </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>autoCommit</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Change the autoCommit state of the renderer. When true, every parameter change is applied immediately. Otherwise you have to call <a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a89b30cc3d6647da7c2712304705b4f64">commit()</a> yourself to apply changes. This allows you to batch changes together for efficiency. </p>

</div>
</div>
<a class="anchor" id="aee73eb4931a7639f96c973f44e956243"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VRay::VRayRenderer::setCamera </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_v_ray_1_1_plugin.html">Plugin</a> &amp;&#160;</td>
          <td class="paramname"><em>plugin</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method is only used when doing out-of-process rendering (<a class="el" href="struct_v_ray_1_1_renderer_options.html#a58807a7ad53d736f04ce61356d67da23">RendererOptions::inProcess</a>=false). It updates the camera plugin used on DR machines when adding/removing CameraPhysical or another specific camera. </p>

</div>
</div>
<a class="anchor" id="aebe9759517bb0e2c6420ced4223a5574"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VRay::VRayRenderer::setComputeDevicesCUDA </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set which devices to use for rendering with the CUDA engine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>The indices of the devices to use as returned by getComputeDevicesCUDA </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if an error occured. Check <a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a9e162e2277748e2a68fbb81f1218cf9d" title="Returns the last error that occurred when a method was called. Use this to understand why a method re...">getLastError()</a> for additional info. </dd></dl>

</div>
</div>
<a class="anchor" id="ab1bc661c508bc732e06cc67d1294d0a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VRay::VRayRenderer::setComputeDevicesCurrentEngine </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set which devices to use for rendering with the current engine (CUDA or OpenCL). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>The indices of the devices to use as returned by getComputeDevicesCurrentEngine </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if an error occured. Check <a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a9e162e2277748e2a68fbb81f1218cf9d" title="Returns the last error that occurred when a method was called. Use this to understand why a method re...">getLastError()</a> for additional info. This will fail without error if the current render mode is CPU. </dd></dl>

</div>
</div>
<a class="anchor" id="ad0b194091a844ee49c9c0c83e6711994"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VRay::VRayRenderer::setComputeDevicesOpenCL </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set which devices to use for rendering with the OpenCL engine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>The indices of the devices to use as returned by getComputeDevicesOpenCL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if an error occured. Check <a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a9e162e2277748e2a68fbb81f1218cf9d" title="Returns the last error that occurred when a method was called. Use this to understand why a method re...">getLastError()</a> for additional info. </dd></dl>

</div>
</div>
<a class="anchor" id="af4c7f41b41cbeb0725119dc8964bce8f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VRay::VRayRenderer::setCropRegion </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>srcWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>srcHeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>rgnLeft</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>rgnTop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets a virtual crop region (rgnLeft, rgnTop, width, height) within a virtual source image space with size srcWidth, srcHeight. width and height are the rendering sizes set by other methods or constructors, etc. Set to an invalid size, like (0, 0, 0, 0), to reset the region and render the whole image. </p>

</div>
</div>
<a class="anchor" id="aa4181fd13621cbc029a22a2f82ebf069"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VRay::VRayRenderer::setCropRegion </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>srcWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>srcHeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>rgnLeft</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>rgnTop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>rgnWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>rgnHeight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets a virtual crop region (rgnLeft, rgnTop, rgnWidth, rgnHeigt) within a virtual source image space with sizes srcWidth, srcHeight. The output image pixel width and height do not change. Set to an invalid size, like (0, 0, 0, 0, 0, 0), to reset the region and render the whole image. </p>

</div>
</div>
<a class="anchor" id="afad2832c160b1760dab59c0cea2a11e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VRay::VRayRenderer::setCurrentFrame </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>frame</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Change the current animation frame number. Setting properties after this will add keyframe values for this frame if useAnimatedValues(true) was called. This is related to the current scene time through the SettingsOutput.frames_per_second parameter. </p>

</div>
</div>
<a class="anchor" id="afda167e5b5f312279dc2edff4c9ee85a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VRay::VRayRenderer::setImprovedDefaultSettings </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Execute this on an empty scene to create some settings plugins and initialize some of their properties to values better than the defaults. The defaults remain as they are for compatibility reasons. This should be done before applying your own settings and before starting a render. To see what got changed, export the scene after that to a file and inspect it. </p>

</div>
</div>
<a class="anchor" id="aeec4f0cab6e5dd70d1e72156f6b8c2ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VRay::VRayRenderer::setOnProgress </td>
          <td>(</td>
          <td class="paramtype">void(*)(<a class="el" href="class_v_ray_1_1_v_ray_renderer.html">VRayRenderer</a> &amp;, const char *msg, int elementNumber, int elementsCount, void *)&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>userData</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set callback function for the event when V-Ray updates its current computation task and the number of workunits done. This is usually used to implement progress bars. </p>

</div>
</div>
<a class="anchor" id="aa98452fafe2f09404e4c796dcb5d718f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , void(T::*)(VRayRenderer &amp;, const char *msg, int elementNumber, int elementsCount, void *) TMethod&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VRay::VRayRenderer::setOnProgress </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>userData</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set callback method for the event when V-Ray updates its current computation task and the number of workunits done. This is usually used to implement progress bars. </p>

</div>
</div>
<a class="anchor" id="ab64b54a22897818a8b7b673c2dc889e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VRay::VRayRenderer::setRenderMode </td>
          <td>(</td>
          <td class="paramtype">RendererOptions::RenderMode&#160;</td>
          <td class="paramname"><em>mode</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Change the render mode to be used for the <em>next</em> rendering. If a rendering is in process it will not be affected. You can switch between Production and RT mode with this without resetting the scene. </p>

</div>
</div>
<a class="anchor" id="ad4103841675886ee7fa640951cae16d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VRay::VRayRenderer::setRenderRegion </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rgnLeft</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rgnTop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rgnWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rgnHeight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the rendering region within the image width and height. (width and height are the rendering sizes set by other methods or constructors, etc.) Set to an invalid size, like (0, 0, 0, 0), to reset the region and render the whole image. </p>

</div>
</div>
<a class="anchor" id="af956a80e38c89d1398fc832cdb07a687"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VRay::VRayRenderer::setResumableRendering </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_v_ray_1_1_resumable_rendering_options.html">ResumableRenderingOptions</a> *&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use this to enable resumable rendering before starting a render. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>Whether to enable or disable for this <a class="el" href="class_v_ray_1_1_v_ray_renderer.html" title="This class wraps the underlying V-Ray render engine and its scene contents. ">VRayRenderer</a> </td></tr>
    <tr><td class="paramname">options</td><td>optional additional settings. Passing NULL is valid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if an error occured. Check <a class="el" href="class_v_ray_1_1_v_ray_renderer.html#a9e162e2277748e2a68fbb81f1218cf9d" title="Returns the last error that occurred when a method was called. Use this to understand why a method re...">getLastError()</a> for additional info. </dd></dl>

</div>
</div>
<a class="anchor" id="ab117de464cb51da71ba2ca57d0abb076"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float VRay::VRayRenderer::setRTImageUpdateDifference </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>difference</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the difference threshold for emitting an RTImageUpdated event. If V-Ray produces an image below the threshold, the event will not be emitted. The initial threshold value is 2.0. </p>

</div>
</div>
<a class="anchor" id="ac095b9aec40fe4956250e5a087060fee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long VRay::VRayRenderer::setRTImageUpdateTimeout </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>timeout</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the maximum time before emitting an RTImageUpdated event. If the timeout is reached, an image will be emitted even if it's the same as the previous update. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">The</td><td>previous timeout value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad32be50f400edab3fc4640938042fa37"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VRay::VRayRenderer::start </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Begins the rendering process in a separate thread. A non-blocking call. Scene changes and DR host changes are forbidden until the RenderStarted event. </p>

</div>
</div>
<a class="anchor" id="af8b75bb6affb2cd272b6156774388456"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VRay::VRayRenderer::useAnimatedValues </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>on</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>When enabled, setting parameter values will add keyframe values for animation. Otherwise the old value is just overwritten. The initial state is off. </p>

</div>
</div>
<a class="anchor" id="a131905876d9222c10b08176a56ed7944"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VRay::VRayRenderer::waitForImageReady </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Waits for rendering to finish, regardless of the outcome (success, cancel, error). If the keepRTRunning flag is set, this event may occur without ending the render session. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if image has been rendered, false if an error occurred. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad3b0e4b59bf82716b222bb15f68250ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VRay::VRayRenderer::waitForImageReady </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>timeout</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Waits for rendering to finish but no more than the specified timeout. If the keepRTRunning flag is set, this event may occur without ending the render session. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>in milliseconds </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if image has been rendered, false if timeout or error occurred. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4d75a7fef2e7be88ff0fef4f6d5d46ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VRay::VRayRenderer::waitForSequenceDone </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Waits for rendering of the sequence to finish, regardless of the outcome (success, cancel, error). </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if rendering of the sequence has finished successfully, false if an error occurred. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="affed33777dbcd62141ccbbf589b619a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VRay::VRayRenderer::waitForSequenceDone </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>timeout</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Waits for rendering of the sequence to finish but no more than the specified timeout. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>in milliseconds </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if rendering of the sequence has finished, false if timeout or error occurred. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/jenkins/ci/slave/workspace/appsdk_linux/VRay_SDK_CPP/include/<a class="el" href="vraysdk_8hpp_source.html">vraysdk.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>VRay</b></li><li class="navelem"><a class="el" href="class_v_ray_1_1_v_ray_renderer.html">VRayRenderer</a></li>
    <li class="footer">Generated on Thu Jul 20 2017 14:57:37 for VRay SDK for C++ by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.4 </li>
  </ul>
</div>
</body>
</html>
